This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    architecture.mdc
    good-behaviour.mdc
    yo.mdc
src/
  llms/
    index.ts
    internal.ts
    llms.txt
  providers/
    claude-code-provider.ts
    clinerules-provider.ts
    codex-provider.ts
    cursor-provider.ts
    index.ts
    windsurf-provider.ts
    zed-provider.ts
  utils/
    path.ts
    rule-formatter.ts
    rule-storage.ts
    similarity.ts
    single-file-helpers.ts
  cli.ts
  index.ts
  schemas.ts
  text.d.ts
  types.ts
.gitignore
.npmignore
.windsurfrules
ARCHITECTURE.md
LICENSE
package.json
README.md
TODO.md
tsconfig.json
vibe-tools.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/architecture.mdc">
---
description: 
globs: 
alwaysApply: true
---
At the end of each task, you need to write all changes to ARCHITECTURE.md.

And by write all changes, I mean modify the architecture of the entire app. If you've changed a function - modify its params/output or whatever you changed.
If you've added a new file - add it to the ARCHITECTURE.md.
</file>

<file path="src/llms/index.ts">
export default [];
</file>

<file path="src/llms/internal.ts">
import { RuleConfig } from "../types"; // Keep RuleConfig if needed, or remove if not used
import { PackageRuleItem } from "../schemas";
// Content from llms.txt
const llmsTxtContent = `
# vibe-rules save
**Purpose:** Saves a rule to the local store (~/.vibe-rules/rules/). This allows you to manage a collection of reusable AI prompts.
**Usage:**
\`\`\`bash
vibe-rules save <name> [options]
\`\`\`
**Arguments:**
- \`<name>\`: The unique name for the rule.
**Options:**
- \`-c, --content <content>\`: Provide the rule content directly as a string.
- \`-f, --file <file>\`: Load the rule content from a specified file (e.g., .mdc or .md). One of --content or --file is required.
- \`-d, --description <desc>\`: An optional description for the rule.
# vibe-rules list
**Purpose:** Lists all rules that have been saved to the common local store (~/.vibe-rules/rules/).
**Usage:**
\`\`\`bash
vibe-rules list
\`\`\`
**Options:**
(None)
# vibe-rules load (or add)
**Purpose:** Applies a previously saved rule to the configuration file(s) of a specific editor or tool. This command formats the rule content correctly for the target editor and places it in the appropriate location.
**Usage:**
\`\`\`bash
vibe-rules load <name> <editor> [options]
vibe-rules add <name> <editor> [options] # Alias
\`\`\`
**Arguments:**
- \`<name>\`: The name of the rule to load/apply (must exist in the local store).
- \`<editor>\`: The target editor or tool type (e.g., cursor, windsurf, claude-code, codex, clinerules, roo).
**Options:**
- \`-g, --global\`: Apply the rule to the global configuration path if supported by the editor (currently supported for claude-code and codex). Defaults to project-local.
- \`-t, --target <path>\`: Specify a custom target file path or directory. This option overrides the default and global paths determined by the editor type.
# vibe-rules install
**Purpose:** Installs rules that are exported from an NPM package. The tool looks for a default export in a file named 'llms.ts' or similar within the package, expecting an array of rule configurations.
**Usage:**
\`\`\`bash
vibe-rules install [packageName]
\`\`\`
**Arguments:**
- \`[packageName]\` (Optional): The name of a specific NPM package to install rules from. If omitted, the command attempts to install rules from all dependencies listed in the current project's package.json file.
**Mechanism:**
- Looks for a module like \`<packageName>/llms\`.
- Expects the default export to be an array conforming to the VibeRulesSchema (array of { name, content, description? }).
- Saves each valid rule found into the common local store (~/.vibe-rules/rules/).
`;
const vibeRulesRepoRules: PackageRuleItem[] = [
  {
    name: "vibe-rules-provider-impl",
    rule: "When adding a new RuleProvider implementation in `src/providers/`, ensure it correctly implements all methods defined in the `RuleProvider` interface (`src/types.ts`), handles both global and local paths appropriately using `src/utils/path.ts` utilities, and generates editor-specific formatting correctly.",
    alwaysApply: true,
    globs: ["src/providers/*.ts", "src/providers/index.ts"],
  },
  {
    name: "vibe-rules-cli-commands",
    rule: "When adding new CLI commands or modifying existing ones in `src/cli.ts`, ensure comprehensive argument parsing using `commander`, validation using Zod schemas from `src/schemas.ts` (if applicable), clear user feedback using `chalk`, and robust error handling for file operations and external calls.",
    alwaysApply: true,
    globs: ["src/cli.ts"],
  },
  // Add the content from llms.txt as a general info rule
  {
    name: "vibe-rules-cli-docs",
    rule: llmsTxtContent,
    description:
      "Documentation for the vibe-rules CLI commands (save, list, load, install).",
    alwaysApply: true,
    globs: ["**/*"], // Apply globally as it's general context
  },
];
export default vibeRulesRepoRules;
</file>

<file path="src/llms/llms.txt">
**Purpose:** Saves a rule to the local store (~/.vibe-rules/rules/). This allows you to manage a collection of reusable AI prompts.

**Usage:**
\`\`\`bash
vibe-rules save <name> [options]
\`\`\`

**Arguments:**
- \`<name>\`: The unique name for the rule.

**Options:**
- \`-c, --content <content>\`: Provide the rule content directly as a string.
- \`-f, --file <file>\`: Load the rule content from a specified file (e.g., .mdc or .md). One of --content or --file is required.
- \`-d, --description <desc>\`: An optional description for the rule.
`,
  },
  {
    name: "vibe-rules-list",
    content: `# vibe-rules list

**Purpose:** Lists all rules that have been saved to the common local store (~/.vibe-rules/rules/).

**Usage:**
\`\`\`bash
vibe-rules list
\`\`\`

**Options:**
(None)
`,
  },
  {
    name: "vibe-rules-load",
    content: `# vibe-rules load (or add)

**Purpose:** Applies a previously saved rule to the configuration file(s) of a specific editor or tool. This command formats the rule content correctly for the target editor and places it in the appropriate location.

**Usage:**
\`\`\`bash
vibe-rules load <name> <editor> [options]
vibe-rules add <name> <editor> [options] # Alias
\`\`\`

**Arguments:**
- \`<name>\`: The name of the rule to load/apply (must exist in the local store).
- \`<editor>\`: The target editor or tool type (e.g., cursor, windsurf, claude-code, codex, clinerules, roo).

**Options:**
- \`-g, --global\`: Apply the rule to the global configuration path if supported by the editor (currently supported for claude-code and codex). Defaults to project-local.
- \`-t, --target <path>\`: Specify a custom target file path or directory. This option overrides the default and global paths determined by the editor type.
`,
  },
  {
    name: "vibe-rules-install",
    content: `# vibe-rules install

**Purpose:** Installs rules that are exported from an NPM package. The tool looks for a default export in a file named 'llms.ts' or similar within the package, expecting an array of rule configurations.

**Usage:**
\`\`\`bash
vibe-rules install [packageName]
\`\`\`

**Arguments:**
- \`[packageName]\` (Optional): The name of a specific NPM package to install rules from. If omitted, the command attempts to install rules from all dependencies listed in the current project's package.json file.

**Mechanism:**
- Looks for a module like \`<packageName>/llms\`.
- Expects the default export to be an array conforming to the VibeRulesSchema (array of { name, content, description? }).
- Saves each valid rule found into the common local store (~/.vibe-rules/rules/).
`,
</file>

<file path="src/utils/rule-formatter.ts">
import { RuleConfig, RuleGeneratorOptions } from "../types";
/**
 * Formats rule content for non-cursor providers that use XML-like tags.
 * Includes additional metadata like alwaysApply and globs in a human-readable format
 * within the rule content.
 */
export function formatRuleWithMetadata(
  config: RuleConfig,
  options?: RuleGeneratorOptions
): string {
  let formattedContent = config.content;
  // Add metadata lines at the beginning of content if they exist
  const metadataLines = [];
  // Add alwaysApply information if provided
  if (options?.alwaysApply !== undefined) {
    metadataLines.push(
      `Always Apply: ${options.alwaysApply ? "true" : "false"} - ${
        options.alwaysApply
          ? "This rule should ALWAYS be applied by the AI"
          : "This rule should only be applied when relevant files are open"
      }`
    );
  }
  // Add globs information if provided
  if (options?.globs) {
    const globsStr = Array.isArray(options.globs)
      ? options.globs.join(", ")
      : options.globs;
    // Skip adding the glob info if it's just a generic catch-all pattern
    const isCatchAllPattern =
      globsStr === "**/*" ||
      (Array.isArray(options.globs) &&
        options.globs.length === 1 &&
        options.globs[0] === "**/*");
    if (!isCatchAllPattern) {
      metadataLines.push(`Always apply this rule in these files: ${globsStr}`);
    }
  }
  // If we have metadata, add it to the beginning of the content
  if (metadataLines.length > 0) {
    formattedContent = `${metadataLines.join("\n")}\n\n${config.content}`;
  }
  return formattedContent;
}
/**
 * Creates a complete XML-like block for a rule, including start/end tags
 * and formatted content with metadata
 */
export function createTaggedRuleBlock(
  config: RuleConfig,
  options?: RuleGeneratorOptions
): string {
  const formattedContent = formatRuleWithMetadata(config, options);
  const startTag = `<${config.name}>`;
  const endTag = `</${config.name}>`;
  return `${startTag}\n${formattedContent}\n${endTag}`;
}
</file>

<file path="src/utils/similarity.ts">
/**
 * Text similarity utilities for finding similar rule names
 */
/**
 * Calculate Levenshtein distance between two strings
 * @param a First string
 * @param b Second string
 * @returns Distance score (lower means more similar)
 */
export function levenshteinDistance(a: string, b: string): number {
  const matrix: number[][] = [];
  // Initialize matrix
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  // Fill matrix
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      const cost = a[j - 1] === b[i - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1, // deletion
        matrix[i][j - 1] + 1, // insertion
        matrix[i - 1][j - 1] + cost // substitution
      );
    }
  }
  return matrix[b.length][a.length];
}
/**
 * Calculate similarity score between two strings (0-1, higher means more similar)
 * @param a First string
 * @param b Second string
 * @returns Similarity score between 0 and 1
 */
export function calculateSimilarity(a: string, b: string): number {
  if (a === b) return 1; // Exact match
  if (!a || !b) return 0; // Handle empty strings
  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
  const maxLength = Math.max(a.length, b.length);
  // Convert distance to similarity score (1 - normalized distance)
  return 1 - distance / maxLength;
}
/**
 * Find similar rule names to the given name
 * @param notFoundName The rule name that wasn't found
 * @param availableRules List of available rule names
 * @param limit Maximum number of similar rules to return
 * @returns Array of similar rule names sorted by similarity (most similar first)
 */
export function findSimilarRules(
  notFoundName: string,
  availableRules: string[],
  limit: number = 5
): string[] {
  if (!availableRules.length) return [];
  // Calculate similarity for each rule
  const scoredRules = availableRules.map((ruleName) => ({
    name: ruleName,
    score: calculateSimilarity(notFoundName, ruleName),
  }));
  // Sort by similarity score (highest first) and take the top n
  return scoredRules
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map((rule) => rule.name);
}
</file>

<file path="src/index.ts">
// Export all types and utilities
export * from "./types";
export * from "./utils/path";
export * from "./utils/similarity";
export * from "./providers";
// Import providers
import { CursorRuleProvider } from "./providers/cursor-provider";
import { WindsurfRuleProvider } from "./providers/windsurf-provider";
// Export concrete implementations
export { CursorRuleProvider, WindsurfRuleProvider };
</file>

<file path="src/schemas.ts">
import { z } from "zod";
export const RuleConfigSchema = z.object({
  name: z.string().min(1, "Rule name cannot be empty"),
  content: z.string().min(1, "Rule content cannot be empty"),
  description: z.string().optional(),
  // Add other fields from RuleConfig if they exist and need validation
});
// Original schema for reference (might still be used elsewhere, e.g., save command)
export const VibeRulesSchema = z.array(RuleConfigSchema);
// --- Schemas for Package Exports (`<packageName>/llms`) ---
// Schema for the flexible rule object format within packages
export const PackageRuleObjectSchema = z.object({
  name: z.string().min(1, "Rule name cannot be empty"),
  rule: z.string().min(1, "Rule content cannot be empty"), // Renamed from content
  description: z.string().optional(),
  alwaysApply: z.boolean().optional(),
  globs: z.union([z.string(), z.array(z.string())]).optional(), // Allow string or array
});
// Schema for a single item in the package export (either a string or the object)
export const PackageRuleItemSchema = z.union([
  z.string().min(1, "Rule string cannot be empty"),
  PackageRuleObjectSchema, // Defined above now
]);
// Schema for the default export of package/llms (array of strings or objects)
export const VibePackageRulesSchema = z.array(PackageRuleItemSchema);
// --- Type Helpers ---
// Basic RuleConfig type
export type RuleConfig = z.infer<typeof RuleConfigSchema>;
// Type for the flexible package rule object
export type PackageRuleObject = z.infer<typeof PackageRuleObjectSchema>;
// Type for a single item in the package export array
export type PackageRuleItem = z.infer<typeof PackageRuleItemSchema>;
</file>

<file path="src/text.d.ts">
declare module "*.txt" {
  const content: string;
  export default content;
}
</file>

<file path=".gitignore">
# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json

# TypeScript
dist/
*.tsbuildinfo

# Editors
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Testing
coverage/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local 

.repomix-*
</file>

<file path=".npmignore">
node_modules
src
tsconfig.json
*.log
.DS_Store
examples
ARCHITECTURE.md
.vscode
.idea
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Artem Murzin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# vibe-rules

A powerful CLI tool for managing and sharing AI rules (prompts, configurations) across different editors and tools.

✨ **Supercharge your workflow!** ✨

Quickly save your favorite prompts and apply them to any supported editor:

```bash
# 1. Save your prompt locally
vibe-rules save my-react-helper -f ./prompts/react-helper.md

# 2. Apply it to Cursor
vibe-rules load my-react-helper cursor
```

Or, automatically install shared prompts from your project's NPM packages:

```bash
# Find packages with 'llms' exports in node_modules and install for Cursor
vibe-rules install cursor
```

(See full command details below.)

## Installation

```bash
# Install globally (bun recommended, npm/yarn also work)
bun i -g vibe-rules
```

## Usage

`vibe-rules` helps you save, list, load, and install AI rules.

### Save a Rule Locally

Store a rule for later use in the common `vibe-rules` store (`~/.vibe-rules/rules/`).

```bash
# Save from a file (e.g., .mdc, .md, or plain text)
vibe-rules save my-rule-name -f ./path/to/rule-content.md

# Save directly from content string
vibe-rules save another-rule -c "This is the rule content."

# Add/update a description
vibe-rules save my-rule-name -d "A concise description of what this rule does."
```

Options:

- `-f, --file <file>`: Path to the file containing the rule content.
- `-c, --content <content>`: Rule content provided as a string. (One of `-f` or `-c` is required).
- `-d, --description <desc>`: An optional description for the rule.

### List Saved Rules

See all the rules you've saved to the common local store.

```bash
vibe-rules list
```

### Load (Apply) a Saved Rule to an Editor

Apply a rule _from your local store_ (`~/.vibe-rules/rules/`) to a specific editor's configuration file. `vibe-rules` handles the formatting.

```bash
# Load 'my-rule-name' for Cursor (creates/updates .cursor/rules/my-rule-name.mdc)
vibe-rules load my-rule-name cursor
# Alias: vibe-rules add my-rule-name cursor

# Load 'my-rule-name' for Claude Code IDE globally (updates ~/.claude/CLAUDE.md)
vibe-rules load my-rule-name claude-code --global
# Alias: vibe-rules add my-rule-name claude-code -g

# Load 'my-rule-name' for Windsurf (appends to ./.windsurfrules)
vibe-rules load my-rule-name windsurf

# Load into a specific custom target path
vibe-rules load my-rule-name cursor -t ./my-project/.cursor-rules/custom-rule.mdc
```

Arguments:

- `<name>`: The name of the rule saved in the local store (`~/.vibe-rules/rules/`).
- `<editor>`: The target editor/tool type. Supported: `cursor`, `windsurf`, `claude-code`, `codex`, `clinerules`, `roo`.

Options:

- `-g, --global`: Apply to the editor's global configuration path (if supported, e.g., `claude-code`, `codex`). Defaults to project-local.
- `-t, --target <path>`: Specify a custom target file path or directory, overriding default/global paths.

### Sharing and Installing Rules via NPM

In the evolving AI landscape, prompts and context are becoming increasingly crucial components of development workflows. Just like code libraries, reusable AI rules and prompts are emerging as shareable assets.

We anticipate more NPM packages will begin exporting standardized AI configurations, often via a `llms` entry point (e.g., `my-package/llms`). `vibe-rules` embraces this trend with the `install` command.

### Install Rules from NPM Packages

⚡ **The easiest way to integrate shared rule sets!** ⚡

Install rules _directly from NPM packages_ into an editor's configuration. `vibe-rules` automatically scans your project's dependencies or a specified package for compatible rule exports.

```bash
# Most common: Install rules from ALL dependencies/devDependencies for Cursor
# Scans package.json, finds packages with 'llms' export, applies rules.
vibe-rules install cursor

# Install rules from a specific package for Cursor
# (Assumes 'my-rule-package' is in node_modules)
vibe-rules install cursor my-rule-package

# Install rules from a specific package into a custom target dir for Roo/Cline
vibe-rules install roo my-rule-package -t ./custom-ruleset/
```

Arguments:

- `<editor>`: The target editor/tool type (mandatory). Supported: `cursor`, `windsurf`, `claude-code`, `codex`, `clinerules`, `roo`.
- `[packageName]` (Optional): The specific NPM package name to install rules from. If omitted, `vibe-rules` scans all dependencies and devDependencies in your project's `package.json`.

Options:

- `-g, --global`: Apply to the editor's global configuration path (if supported).
- `-t, --target <path>`: Specify a custom target file path or directory.

**How `install` finds rules:**

1.  Looks for installed NPM packages (either the specified one or all dependencies based on whether `[packageName]` is provided).
2.  Attempts to dynamically import a module named `llms` from the package root (e.g., `require('my-rule-package/llms')` or `import('my-rule-package/llms')`). Handles both CommonJS and ESM.
3.  Examines the `default export` of the `llms` module:
    - **If it's a string:** Treats it as a single rule's content.
    - **If it's an array:** Expects an array of rule strings or rule objects.
      - Rule Object Shape: `{ name: string, rule: string, description?: string, alwaysApply?: boolean, globs?: string | string[] }` (Validated using Zod). Note the use of `rule` for content.
4.  Uses the appropriate editor provider (`cursor`, `windsurf`, etc.) to format and apply each found rule to the correct target path (respecting `-g` and `-t` options). Metadata like `alwaysApply` and `globs` is passed to the provider if present in a rule object.
5.  **Important:** Rules installed this way are applied _directly_ to the editor configuration; they are **not** saved to the common local store (`~/.vibe-rules/rules/`). Use `vibe-rules save` for that.

## Supported Editors & Formats

`vibe-rules` automatically handles formatting for:

- **Cursor (`cursor`)**:
  - Creates/updates individual `.mdc` files in `./.cursor/rules/` (local) or `~/.cursor/rules/` (global, if supported via `-t`).
  - Uses frontmatter for metadata (`description`, `alwaysApply`, `globs`).
- **Windsurf (`windsurf`)**:
  - Appends rules wrapped in `<rule-name>` tags to `./.windsurfrules` (local) or a target file specified by `-t`. Global (`-g`) is not typically used.
- **Claude Code (`claude-code`)**:
  - Appends/updates rules within a `<vibe-tools Integration>` block in `./CLAUDE.md` (local) or `~/.claude/CLAUDE.md` (global).
- **Codex (`codex`)**:
  - Appends/updates rules within a `<vibe-tools Integration>` block in `./codex.md` (local) or `~/.codex/instructions.md` (global).
- **Cline/Roo (`clinerules`, `roo`)**:
  - Creates/updates individual `.md` files within `./.clinerules/` (local) or a target directory specified by `-t`. Global (`-g`) is not typically used.

## Development

```bash
# Clone the repo
git clone https://github.com/your-username/vibe-rules.git
cd vibe-rules

# Install dependencies
bun install

# Run tests (if any)
bun test

# Build the project
bun run build

# Link for local development testing
bun link
# Now you can use 'vibe-rules' command locally
```

## License

MIT
</file>

<file path="TODO.md">
For cursor add manual header for autoapply
export vibe-rules llms.txt
proprely handle array with object structure - support for globs
llms.txt same way as sitemap.xml/sitemap_index.xml
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "declaration": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.test.ts"]
}
</file>

<file path="vibe-tools.config.json">
{
  "web": {
    "provider": "perplexity",
    "model": "sonar-pro"
  },
  "plan": {
    "fileProvider": "openrouter",
    "thinkingProvider": "openrouter",
    "fileModel": "google/gemini-2.5-flash-preview",
    "thinkingModel": "google/gemini-2.5-flash-preview"
  },
  "repo": {
    "provider": "gemini",
    "model": "gemini-2.5-flash-preview"
  },
  "doc": {
    "provider": "openrouter",
    "model": "google/gemini-2.5-flash-preview"
  },
  "ide": "cursor"
}
</file>

<file path=".cursor/rules/good-behaviour.mdc">
---
description: 
globs: 
alwaysApply: true
---
In the beginning of each task, always use vibe-tools repo. ENSURE 100% you use vibe-tools repo before writing any code. DO NOT look up any files before you vibe-tools repo.

Keep the code changes as minimal as you can, only changing the absolute necessary parts. Do not change anything directly unrelated to what user asked.  

Keep it as simple as possible, fewest lines of code as possible, as clean as possible
</file>

<file path=".cursor/rules/yo.mdc">
---
description: 
globs: 
alwaysApply: true
---
If you need my input to answer a question or when you finish a task and want to know what to do next you must send me a yo using the yo-mcp MCP tool.

In the yo you MUST provide ONLY a very short message (think like an email subject line) for why you need my attention / input.

Then reply with your update / question to the normal chat.

This mcp server should be called with this tool name: "mcp_yo-mcp_com_yo"
</file>

<file path="src/providers/claude-code-provider.ts">
import * as fs from "fs-extra";
import * as path from "path";
import {
  RuleConfig,
  RuleProvider,
  RuleGeneratorOptions,
  RuleType,
} from "../types";
import { getRulePath, getDefaultTargetPath } from "../utils/path";
import {
  formatRuleWithMetadata,
  createTaggedRuleBlock,
} from "../utils/rule-formatter";
import { appendOrUpdateTaggedBlock } from "../utils/single-file-helpers";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
import chalk from "chalk";
export class ClaudeCodeRuleProvider implements RuleProvider {
  private readonly ruleType = RuleType.CLAUDE_CODE;
  /**
   * Generates formatted content for Claude Code including metadata.
   * This content is intended to be placed within the <vibe-tools Integration> block.
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    // Format the content with metadata
    return formatRuleWithMetadata(config, options);
  }
  /**
   * Saves a rule definition to internal storage for later use.
   * @param config - The rule configuration.
   * @returns Path where the rule definition was saved internally.
   */
  async saveRule(config: RuleConfig): Promise<string> {
    return saveInternalRule(RuleType.CLAUDE_CODE, config);
  }
  /**
   * Loads a rule definition from internal storage.
   * @param name - The name of the rule to load.
   * @returns The RuleConfig if found, otherwise null.
   */
  async loadRule(name: string): Promise<RuleConfig | null> {
    return loadInternalRule(RuleType.CLAUDE_CODE, name);
  }
  /**
   * Lists rule definitions available in internal storage.
   * @returns An array of rule names.
   */
  async listRules(): Promise<string[]> {
    return listInternalRules(RuleType.CLAUDE_CODE);
  }
  /**
   * Applies a rule by updating the <vibe-tools> section in the target CLAUDE.md.
   * If targetPath is omitted, it determines local vs global based on isGlobal option.
   */
  async appendRule(
    name: string,
    targetPath?: string,
    isGlobal: boolean = false,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const rule = await this.loadRule(name);
    if (!rule) {
      console.error(`Rule '${name}' not found for type ${this.ruleType}.`);
      return false;
    }
    const destinationPath =
      targetPath || getRulePath(this.ruleType, name, isGlobal); // name might not be needed by getRulePath here
    return this.appendFormattedRule(rule, destinationPath, isGlobal, options);
  }
  /**
   * Formats and applies a rule directly from a RuleConfig object using XML-like tags.
   * If a rule with the same name (tag) already exists, its content is updated.
   */
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const destinationPath = targetPath;
    // Ensure the parent directory exists
    fs.ensureDirSync(path.dirname(destinationPath));
    const newBlock = createTaggedRuleBlock(config, options);
    let fileContent = "";
    if (await fs.pathExists(destinationPath)) {
      fileContent = await fs.readFile(destinationPath, "utf-8");
    }
    // Escape rule name for regex
    const ruleNameRegex = config.name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(
      `^<${ruleNameRegex}>[\\s\\S]*?</${ruleNameRegex}>`,
      "m"
    );
    let updatedContent: string;
    const match = fileContent.match(regex);
    if (match) {
      // Rule exists, replace its content
      console.log(
        chalk.blue(
          `Updating existing rule block for "${config.name}" in ${destinationPath}...`
        )
      );
      updatedContent = fileContent.replace(regex, newBlock);
    } else {
      // Rule doesn't exist, append it
      // Attempt to append within <vibe-tools Integration> if possible
      const integrationStartTag = "<vibe-tools Integration>";
      const integrationEndTag = "</vibe-tools Integration>";
      const startIndex = fileContent.indexOf(integrationStartTag);
      const endIndex = fileContent.indexOf(integrationEndTag);
      console.log(
        chalk.blue(
          `Appending new rule block for "${config.name}" to ${destinationPath}...`
        )
      );
      if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {
        // Insert before the end tag of the integration block
        const insertionPoint = endIndex;
        const before = fileContent.slice(0, insertionPoint);
        const after = fileContent.slice(insertionPoint);
        updatedContent = `${before.trimEnd()}\n\n${newBlock}\n\n${after.trimStart()}`;
      } else {
        // Append to the end of the file if integration block not found or invalid
        const separator = fileContent.trim().length > 0 ? "\n\n" : "";
        updatedContent = fileContent + separator + newBlock;
      }
    }
    try {
      await fs.writeFile(destinationPath, updatedContent.trim() + "\n");
      return true;
    } catch (error) {
      console.error(
        chalk.red(`Error writing updated rules to ${destinationPath}: ${error}`)
      );
      return false;
    }
  }
}
</file>

<file path="src/providers/clinerules-provider.ts">
import * as fs from "fs-extra";
import * as path from "path";
import {
  RuleConfig,
  RuleProvider,
  RuleGeneratorOptions,
  RuleType,
} from "../types";
import {
  getRulePath, // Returns the .clinerules directory path
  ensureDirectoryExists,
  getDefaultTargetPath,
  slugifyRuleName,
} from "../utils/path";
import {
  formatRuleWithMetadata,
  createTaggedRuleBlock,
} from "../utils/rule-formatter";
import chalk from "chalk";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
// Helper function specifically for clinerules/roo setup
// Focuses on the directory structure: .clinerules/vibe-tools.md
async function setupClinerulesDirectory(
  clinerulesDirPath: string,
  rulesContent: string
): Promise<void> {
  await fs.ensureDir(clinerulesDirPath); // Ensure the .clinerules directory exists
  const vibeToolsRulePath = path.join(clinerulesDirPath, "vibe-tools.md");
  const rulesTemplate = rulesContent.replace(/\r\n/g, "\n").trim();
  // Wrap content with <vibe-tools> tags if not already present
  const startTag = "<vibe-tools Integration>";
  const endTag = "</vibe-tools Integration>";
  let contentToWrite = rulesTemplate;
  if (!contentToWrite.includes(startTag)) {
    contentToWrite = `${startTag}\n${rulesTemplate}\n${endTag}`;
  }
  await fs.writeFile(vibeToolsRulePath, contentToWrite + "\n");
}
export class ClinerulesRuleProvider implements RuleProvider {
  private readonly ruleType = RuleType.CLINERULES;
  /**
   * Generates formatted content for Clinerules/Roo including metadata.
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    return formatRuleWithMetadata(config, options);
  }
  /**
   * Saves a rule definition to internal storage for later use.
   * @param config - The rule configuration.
   * @returns Path where the rule definition was saved internally.
   */
  async saveRule(config: RuleConfig): Promise<string> {
    return saveInternalRule(this.ruleType, config);
  }
  /**
   * Loads a rule definition from internal storage.
   * @param name - The name of the rule to load.
   * @returns The RuleConfig if found, otherwise null.
   */
  async loadRule(name: string): Promise<RuleConfig | null> {
    return loadInternalRule(this.ruleType, name);
  }
  /**
   * Lists rule definitions available in internal storage.
   * @returns An array of rule names.
   */
  async listRules(): Promise<string[]> {
    return listInternalRules(this.ruleType);
  }
  /**
   * Applies a rule by setting up the .clinerules/vibe-tools.md structure.
   * Always targets the project-local .clinerules directory.
   */
  async appendRule(
    name: string,
    targetPath?: string, // If provided, should be the .clinerules directory path
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const rule = await this.loadRule(name);
    if (!rule) {
      console.error(
        `Rule '${name}' not found for type ${RuleType.CLINERULES}/${RuleType.ROO}.`
      );
      return false;
    }
    // getRulePath for CLINERULES/ROO returns the directory path
    const destinationDir = targetPath || getRulePath(RuleType.CLINERULES, name); // name is ignored here
    try {
      const contentToAppend = this.generateRuleContent(rule, options);
      await setupClinerulesDirectory(destinationDir, contentToAppend);
      console.log(
        chalk.green(
          `Successfully set up ${RuleType.CLINERULES}/${RuleType.ROO} rules in: ${destinationDir}`
        )
      );
      return true;
    } catch (error) {
      console.error(
        chalk.red(
          `Error setting up ${RuleType.CLINERULES}/${RuleType.ROO} rules in ${destinationDir}:`
        ),
        error
      );
      return false;
    }
  }
  /**
   * Formats and applies a rule directly from a RuleConfig object.
   */
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string, // Should now receive the correct .../.clinerules/slugified-name.md path
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    // Ensure the parent .clinerules directory exists
    const parentDir = path.dirname(targetPath);
    ensureDirectoryExists(parentDir);
    // Generate the content
    const content = this.generateRuleContent(config, options);
    // Log metadata inclusion (optional, but kept from previous state)
    if (options?.alwaysApply !== undefined || options?.globs) {
      console.log(
        chalk.blue(
          `  Including metadata in rule content: alwaysApply=${options.alwaysApply}, globs=${JSON.stringify(options.globs)}`
        )
      );
    }
    try {
      // Write directly to the target file path
      await fs.writeFile(targetPath, content, "utf-8");
      console.log(
        chalk.green(
          `Successfully applied rule "${config.name}" to ${targetPath}`
        )
      );
      return true;
    } catch (error) {
      console.error(
        chalk.red(
          `Error applying rule "${config.name}" to ${targetPath}: ${error}`
        )
      );
      return false;
    }
  }
}
</file>

<file path="src/providers/codex-provider.ts">
import * as fs from "fs-extra";
import * as path from "path";
import {
  RuleConfig,
  RuleProvider,
  RuleGeneratorOptions,
  RuleType,
} from "../types";
import { getRulePath, getDefaultTargetPath } from "../utils/path";
import {
  formatRuleWithMetadata,
  createTaggedRuleBlock,
} from "../utils/rule-formatter";
import chalk from "chalk";
import * as fsPromises from "fs/promises";
import { appendOrUpdateTaggedBlock } from "../utils/single-file-helpers";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
export class CodexRuleProvider implements RuleProvider {
  private readonly ruleType = RuleType.CODEX;
  /**
   * Generates formatted content for Codex including metadata.
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    return formatRuleWithMetadata(config, options);
  }
  /**
   * Saves a rule definition to internal storage for later use.
   * @param config - The rule configuration.
   * @returns Path where the rule definition was saved internally.
   */
  async saveRule(config: RuleConfig): Promise<string> {
    return saveInternalRule(this.ruleType, config);
  }
  /**
   * Loads a rule definition from internal storage.
   * @param name - The name of the rule to load.
   * @returns The RuleConfig if found, otherwise null.
   */
  async loadRule(name: string): Promise<RuleConfig | null> {
    return loadInternalRule(this.ruleType, name);
  }
  /**
   * Lists rule definitions available in internal storage.
   * @returns An array of rule names.
   */
  async listRules(): Promise<string[]> {
    return listInternalRules(this.ruleType);
  }
  /**
   * Appends a rule loaded from internal storage to the target Codex file.
   * @param name - The name of the rule in internal storage.
   * @param targetPath - Optional explicit target file path.
   * @param isGlobal - Hint for global context (uses ~/.codex/instructions.md).
   * @param options - Additional generation options.
   * @returns True on success, false on failure.
   */
  async appendRule(
    name: string,
    targetPath?: string,
    isGlobal: boolean = false,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const ruleConfig = await this.loadRule(name);
    if (!ruleConfig) {
      console.error(`Rule "${name}" not found in internal storage.`);
      return false;
    }
    const actualTargetPath =
      targetPath ?? getRulePath(this.ruleType, "", isGlobal);
    return this.appendFormattedRule(
      ruleConfig,
      actualTargetPath,
      isGlobal,
      options
    );
  }
  /**
   * Formats and applies a rule directly from a RuleConfig object using XML-like tags.
   * If a rule with the same name (tag) already exists, its content is updated.
   * @param config - The rule configuration to apply.
   * @param targetPath - The target file path (e.g., ~/.codex/instructions.md or ./codex.md).
   * @param isGlobal - Unused by this method but kept for interface compatibility.
   * @param options - Additional options like description, alwaysApply, globs.
   * @returns True on success, false on failure.
   */
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal?: boolean | undefined,
    options?: RuleGeneratorOptions | undefined
  ): Promise<boolean> {
    // Delegate to the shared helper, ensuring insertion within <vibe-tools>
    return appendOrUpdateTaggedBlock(
      targetPath,
      config,
      options,
      true // Append inside <vibe-tools Integration>
    );
  }
}
</file>

<file path="src/providers/index.ts">
import { RuleProvider, RuleType } from "../types";
import { CursorRuleProvider } from "./cursor-provider";
import { WindsurfRuleProvider } from "./windsurf-provider";
import { ClaudeCodeRuleProvider } from "./claude-code-provider";
import { CodexRuleProvider } from "./codex-provider";
import { ClinerulesRuleProvider } from "./clinerules-provider";
import { ZedRuleProvider } from "./zed-provider";
/**
 * Factory function to get the appropriate rule provider based on rule type
 */
export function getRuleProvider(ruleType: RuleType): RuleProvider {
  switch (ruleType) {
    case RuleType.CURSOR:
      return new CursorRuleProvider();
    case RuleType.WINDSURF:
      return new WindsurfRuleProvider();
    case RuleType.CLAUDE_CODE:
      return new ClaudeCodeRuleProvider();
    case RuleType.CODEX:
      return new CodexRuleProvider();
    case RuleType.CLINERULES:
    case RuleType.ROO:
      return new ClinerulesRuleProvider();
    case RuleType.ZED:
      return new ZedRuleProvider();
    case RuleType.CUSTOM:
    default:
      throw new Error(`Unsupported rule type: ${ruleType}`);
  }
}
</file>

<file path="src/providers/windsurf-provider.ts">
import * as fs from "fs-extra";
import * as path from "path";
import {
  RuleConfig,
  RuleProvider,
  RuleType,
  RuleGeneratorOptions,
} from "../types";
import { getRulePath, getDefaultTargetPath } from "../utils/path";
import {
  formatRuleWithMetadata,
  createTaggedRuleBlock,
} from "../utils/rule-formatter";
import { appendOrUpdateTaggedBlock } from "../utils/single-file-helpers";
import chalk from "chalk";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
export class WindsurfRuleProvider implements RuleProvider {
  private readonly ruleType = RuleType.WINDSURF;
  /**
   * Format rule content with XML tags
   */
  private formatRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    return createTaggedRuleBlock(config, options);
  }
  /**
   * Generates formatted rule content with Windsurf XML tags
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    return this.formatRuleContent(config, options);
  }
  /**
   * Saves a rule definition to internal storage for later use.
   * @param config - The rule configuration.
   * @returns Path where the rule definition was saved internally.
   */
  async saveRule(config: RuleConfig): Promise<string> {
    return saveInternalRule(RuleType.WINDSURF, config);
  }
  /**
   * Loads a rule definition from internal storage.
   * @param name - The name of the rule to load.
   * @returns The RuleConfig if found, otherwise null.
   */
  async loadRule(name: string): Promise<RuleConfig | null> {
    return loadInternalRule(RuleType.WINDSURF, name);
  }
  /**
   * Lists rule definitions available in internal storage.
   * @returns An array of rule names.
   */
  async listRules(): Promise<string[]> {
    return listInternalRules(RuleType.WINDSURF);
  }
  /**
   * Append a windsurf rule to a target file
   */
  async appendRule(
    name: string,
    targetPath?: string,
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const rule = await this.loadRule(name);
    if (!rule) {
      console.error(`Rule '${name}' not found for type ${this.ruleType}.`);
      return false;
    }
    // Windsurf typically doesn't use global paths or specific rule name paths for the target
    // It uses a single default file.
    const destinationPath = targetPath || getDefaultTargetPath(this.ruleType);
    return this.appendFormattedRule(rule, destinationPath, false, options);
  }
  /**
   * Format and append a rule directly from a RuleConfig object.
   * If a rule with the same name (tag) already exists, its content is updated.
   */
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    // Delegate to the shared helper
    return appendOrUpdateTaggedBlock(targetPath, config, options, false);
  }
}
</file>

<file path="src/providers/zed-provider.ts">
import path from "path";
import fs from "fs-extra";
import {
  RuleConfig,
  RuleProvider,
  RuleType,
  RuleGeneratorOptions,
} from "../types";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
import { createTaggedRuleBlock } from "../utils/rule-formatter";
import { appendOrUpdateTaggedBlock } from "../utils/single-file-helpers";
import { getDefaultTargetPath } from "../utils/path";
export class ZedRuleProvider implements RuleProvider {
  async saveRule(config: RuleConfig): Promise<string> {
    return saveInternalRule(RuleType.ZED, config);
  }
  async loadRule(name: string): Promise<RuleConfig | null> {
    return loadInternalRule(RuleType.ZED, name);
  }
  async listRules(): Promise<string[]> {
    return listInternalRules(RuleType.ZED);
  }
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    // Zed .rules files are expected to be plain text or use a format
    // compatible with simple tagged blocks if we are managing multiple rules within it.
    // For consistency with Windsurf and other single-file providers, we use tagged blocks.
    return createTaggedRuleBlock(config, options);
  }
  async appendRule(
    name: string,
    targetPath?: string,
    isGlobal?: boolean, // isGlobal is not typically used for Zed's .rules
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const ruleConfig = await this.loadRule(name);
    if (!ruleConfig) {
      console.error(`Rule "${name}" not found in internal ZED storage.`);
      return false;
    }
    const finalTargetPath =
      targetPath || getDefaultTargetPath(RuleType.ZED, isGlobal);
    return this.appendFormattedRule(
      ruleConfig,
      finalTargetPath,
      isGlobal,
      options
    );
  }
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal?: boolean, // isGlobal is not typically used for Zed's .rules
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    // Zed .rules files are at the root of the worktree, so isGlobal is likely false.
    // We don't append inside a specific <vibe-tools Integration> block by default for .rules
    return appendOrUpdateTaggedBlock(targetPath, config, options, false);
  }
}
</file>

<file path="src/utils/rule-storage.ts">
import * as fs from "fs-extra";
import * as path from "path";
import { RuleConfig, RuleType } from "../types";
import { getInternalRuleStoragePath } from "./path";
const RULE_EXTENSION = ".txt";
/**
 * Saves a rule definition to the internal storage (~/.vibe-rules/<ruleType>/<name>.txt).
 * @param ruleType - The type of the rule, determining the subdirectory.
 * @param config - The rule configuration object containing name and content.
 * @returns The full path where the rule was saved.
 * @throws Error if file writing fails.
 */
export async function saveInternalRule(
  ruleType: RuleType,
  config: RuleConfig
): Promise<string> {
  const storagePath = getInternalRuleStoragePath(ruleType, config.name);
  const dir = path.dirname(storagePath);
  await fs.ensureDir(dir); // Ensure the directory exists
  await fs.writeFile(storagePath, config.content, "utf-8");
  console.debug(`[Rule Storage] Saved internal rule: ${storagePath}`);
  return storagePath;
}
/**
 * Loads a rule definition from the internal storage.
 * @param ruleType - The type of the rule.
 * @param name - The name of the rule to load.
 * @returns The RuleConfig object if found, otherwise null.
 */
export async function loadInternalRule(
  ruleType: RuleType,
  name: string
): Promise<RuleConfig | null> {
  const storagePath = getInternalRuleStoragePath(ruleType, name);
  try {
    if (!(await fs.pathExists(storagePath))) {
      console.debug(`[Rule Storage] Internal rule not found: ${storagePath}`);
      return null;
    }
    const content = await fs.readFile(storagePath, "utf-8");
    console.debug(`[Rule Storage] Loaded internal rule: ${storagePath}`);
    return { name, content };
  } catch (error: any) {
    // Log other errors but still return null as the rule couldn't be loaded
    console.error(
      `[Rule Storage] Error loading internal rule ${name} (${ruleType}): ${error.message}`
    );
    return null;
  }
}
/**
 * Lists the names of all rules stored internally for a given rule type.
 * @param ruleType - The type of the rule.
 * @returns An array of rule names.
 */
export async function listInternalRules(ruleType: RuleType): Promise<string[]> {
  // Use getInternalRuleStoragePath with a dummy name to get the directory path
  const dummyPath = getInternalRuleStoragePath(ruleType, "__dummy__");
  const storageDir = path.dirname(dummyPath);
  try {
    if (!(await fs.pathExists(storageDir))) {
      console.debug(
        `[Rule Storage] Internal rule directory not found for ${ruleType}: ${storageDir}`
      );
      return []; // Directory doesn't exist, no rules
    }
    const files = await fs.readdir(storageDir);
    const ruleNames = files
      .filter((file) => file.endsWith(RULE_EXTENSION))
      .map((file) => path.basename(file, RULE_EXTENSION));
    console.debug(
      `[Rule Storage] Listed ${ruleNames.length} internal rules for ${ruleType}`
    );
    return ruleNames;
  } catch (error: any) {
    console.error(
      `[Rule Storage] Error listing internal rules for ${ruleType}: ${error.message}`
    );
    return []; // Return empty list on error
  }
}
</file>

<file path="src/types.ts">
/**
 * Rule type definitions for the vibe-rules utility
 */
export type * from "./schemas";
export interface RuleConfig {
  name: string;
  content: string;
  description?: string;
  // Additional properties can be added as needed
}
export const RuleType = {
  CURSOR: "cursor",
  WINDSURF: "windsurf",
  CLAUDE_CODE: "claude-code",
  CODEX: "codex",
  CLINERULES: "clinerules",
  ROO: "roo",
  ZED: "zed",
  CUSTOM: "custom",
} as const;
export type RuleTypeArray = (typeof RuleType)[keyof typeof RuleType][];
export type RuleType = (typeof RuleType)[keyof typeof RuleType];
export interface RuleProvider {
  /**
   * Creates a new rule file with the given content
   */
  saveRule(config: RuleConfig, options?: RuleGeneratorOptions): Promise<string>;
  /**
   * Loads a rule from storage
   */
  loadRule(name: string): Promise<RuleConfig | null>;
  /**
   * Lists all available rules
   */
  listRules(): Promise<string[]>;
  /**
   * Appends a rule to an existing file
   */
  appendRule(name: string, targetPath?: string): Promise<boolean>;
  /**
   * Formats and appends a rule directly from a RuleConfig object
   */
  appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal?: boolean,
    options?: RuleGeneratorOptions
  ): Promise<boolean>;
  /**
   * Generates formatted rule content with editor-specific formatting
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string;
}
export interface RuleGeneratorOptions {
  description?: string;
  isGlobal?: boolean;
  alwaysApply?: boolean;
  globs?: string | string[];
  debug?: boolean;
  // Additional options for specific rule types
}
</file>

<file path=".windsurfrules">
<vibe-tools>
# Instructions
Use the following commands to get AI assistance:

**Direct Model Queries:**
`vibe-tools ask "<your question>" --provider <provider> --model <model>` - Ask any model from any provider a direct question (e.g., `vibe-tools ask "What is the capital of France?" --provider openai --model o3-mini`). Note that this command is generally less useful than other commands like `repo` or `plan` because it does not include any context from your codebase or repository. In general you should not use the ask command because it does not include any context. The other commands like `web`, `doc`, `repo`, or `plan` are usually better. If you are using it, make sure to include in your question all the information and context that the model might need to answer usefully.

**Ask Command Options:**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, modelbox, openrouter, or xai)
--model=<model>: Model to use (required for the ask command)
--reasoning-effort=<low|medium|high>: Control the depth of reasoning for supported models (OpenAI o1/o3-mini models and Claude 3.7 Sonnet). Higher values produce more thorough responses for complex questions.
--with-doc=<doc_url>: Fetch content from a document URL and include it as context for the question (e.g., `vibe-tools ask "What does this spec require?" --with-doc=https://example.com/spec.pdf`)

**Implementation Planning:**
`vibe-tools plan "<query>"` - Generate a focused implementation plan using AI (e.g., `vibe-tools plan "Add user authentication to the login page"`)
The plan command uses multiple AI models to:
1. Identify relevant files in your codebase (using Gemini by default)
2. Extract content from those files
3. Generate a detailed implementation plan (using OpenAI o3-mini by default)

**Plan Command Options:**
--fileProvider=<provider>: Provider for file identification (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--thinkingProvider=<provider>: Provider for plan generation (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--fileModel=<model>: Model to use for file identification
--thinkingModel=<model>: Model to use for plan generation
--with-doc=<doc_url>: Fetch content from a document URL and include it as context for both file identification and planning (e.g., `vibe-tools plan "implement feature X following the spec" --with-doc=https://example.com/feature-spec`)

**Web Search:**
`vibe-tools web "<your question>"` - Get answers from the web using a provider that supports web search (e.g., Perplexity models and Gemini Models either directly or from OpenRouter or ModelBox) (e.g., `vibe-tools web "latest shadcn/ui installation instructions"`)
Note: web is a smart autonomous agent with access to the internet and an extensive up to date knowledge base. Web is NOT a web search engine. Always ask the agent for what you want using a proper sentence, do not just send it a list of keywords. In your question to web include the context and the goal that you're trying to acheive so that it can help you most effectively.
when using web for complex queries suggest writing the output to a file somewhere like local-research/<query summary>.md. However if user provides a specific url, you should always use any command with --with-doc instead of web.

**Web Command Options:**
--provider=<provider>: AI provider to use (perplexity, gemini, modelbox, or openrouter)

**Repository Context:**
`vibe-tools repo "<your question>" [--subdir=<path>] [--from-github=<username/repo>] [--with-doc=<doc_url>]` - Get context-aware answers about this repository using Google Gemini (e.g., `vibe-tools repo "explain authentication flow"`). Use the optional `--subdir` parameter to analyze a specific subdirectory instead of the entire repository (e.g., `vibe-tools repo "explain the code structure" --subdir=src/components`). Use the optional `--from-github` parameter to analyze a remote GitHub repository without cloning it locally (e.g., `vibe-tools repo "explain the authentication system" --from-github=username/repo-name`). Use the optional `--with-doc` parameter to include content from a URL as additional context (e.g., `vibe-tools repo "implement feature X following the design spec" --with-doc=https://example.com/design-spec`).

**Documentation Generation:**
`vibe-tools doc [options] [--with-doc=<doc_url>]` - Generate comprehensive documentation for this repository (e.g., `vibe-tools doc --output docs.md`). Can incorporate document context from a URL (e.g., `vibe-tools doc --with-doc=https://example.com/existing-docs`).

**YouTube Video Analysis:**
`vibe-tools youtube "<youtube-url>" [question] [--type=<summary|transcript|plan|review|custom>]` - Analyze YouTube videos and generate detailed reports (e.g., `vibe-tools youtube "https://youtu.be/43c-Sm5GMbc" --type=summary`)
Note: The YouTube command requires a `GEMINI_API_KEY` to be set in your environment or .vibe-tools.env file as the GEMINI API is the only interface that supports YouTube analysis.

**GitHub Information:**
`vibe-tools github pr [number]` - Get the last 10 PRs, or a specific PR by number (e.g., `vibe-tools github pr 123`)
`vibe-tools github issue [number]` - Get the last 10 issues, or a specific issue by number (e.g., `vibe-tools github issue 456`)

**ClickUp Information:**
`vibe-tools clickup task <task_id>` - Get detailed information about a ClickUp task including description, comments, status, assignees, and metadata (e.g., `vibe-tools clickup task "task_id"`)

**Model Context Protocol (MCP) Commands:**
Use the following commands to interact with MCP servers and their specialized tools:
`vibe-tools mcp search "<query>"` - Search the MCP Marketplace for available servers that match your needs (e.g., `vibe-tools mcp search "git repository management"`)
`vibe-tools mcp run "<query>"` - Execute MCP server tools using natural language queries (e.g., `vibe-tools mcp run "list files in the current directory" --provider=openrouter`). The query must include sufficient information for vibe-tools to determine which server to use, provide plenty of context.

The `search` command helps you discover servers in the MCP Marketplace based on their capabilities and your requirements. The `run` command automatically selects and executes appropriate tools from these servers based on your natural language queries. If you want to use a specific server include the server name in your query. E.g. `vibe-tools mcp run "using the mcp-server-sqlite list files in directory --provider=openrouter"`

**Notes on MCP Commands:**
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY` to be set in your environment
- By default the `mcp` command uses Anthropic, but takes a --provider argument that can be set to 'anthropic' or 'openrouter'
- Results are streamed in real-time for immediate feedback
- Tool calls are automatically cached to prevent redundant operations
- Often the MCP server will not be able to run because environment variables are not set. If this happens ask the user to add the missing environment variables to the cursor tools env file at ~/.vibe-tools/.env

**Stagehand Browser Automation:**
`vibe-tools browser open <url> [options]` - Open a URL and capture page content, console logs, and network activity (e.g., `vibe-tools browser open "https://example.com" --html`)
`vibe-tools browser act "<instruction>" --url=<url | 'current'> [options]` - Execute actions on a webpage using natural language instructions (e.g., `vibe-tools browser act "Click Login" --url=https://example.com`)
`vibe-tools browser observe "<instruction>" --url=<url> [options]` - Observe interactive elements on a webpage and suggest possible actions (e.g., `vibe-tools browser observe "interactive elements" --url=https://example.com`)
`vibe-tools browser extract "<instruction>" --url=<url> [options]` - Extract data from a webpage based on natural language instructions (e.g., `vibe-tools browser extract "product names" --url=https://example.com/products`)

**Notes on Browser Commands:**
- All browser commands are stateless unless --connect-to is used to connect to a long-lived interactive session. In disconnected mode each command starts with a fresh browser instance and closes it when done.
- When using `--connect-to`, special URL values are supported:
  - `current`: Use the existing page without reloading
  - `reload-current`: Use the existing page and refresh it (useful in development)
  - If working interactively with a user you should always use --url=current unless you specifically want to navigate to a different page. Setting the url to anything else will cause a page refresh loosing current state.
- Multi step workflows involving state or combining multiple actions are supported in the `act` command using the pipe (|) separator (e.g., `vibe-tools browser act "Click Login | Type 'user@example.com' into email | Click Submit" --url=https://example.com`)
- Video recording is available for all browser commands using the `--video=<directory>` option. This will save a video of the entire browser interaction at 1280x720 resolution. The video file will be saved in the specified directory with a timestamp.
- DO NOT ask browser act to "wait" for anything, the wait command is currently disabled in Stagehand.

**Tool Recommendations:**
- `vibe-tools web` is best for general web information not specific to the repository. Generally call this without additional arguments.
- `vibe-tools repo` is ideal for repository-specific questions, planning, code review and debugging. E.g. `vibe-tools repo "Review recent changes to command error handling looking for mistakes, omissions and improvements"`. Generally call this without additional arguments.
- `vibe-tools plan` is ideal for planning tasks. E.g. `vibe-tools plan "Adding authentication with social login using Google and Github"`. Generally call this without additional arguments.
- `vibe-tools doc` generates documentation for local or remote repositories.
- `vibe-tools youtube` analyzes YouTube videos to generate summaries, transcripts, implementation plans, or custom analyses
- `vibe-tools browser` is useful for testing and debugging web apps and uses Stagehand
- `vibe-tools mcp` enables interaction with specialized tools through MCP servers (e.g., for Git operations, file system tasks, or custom tools)
- When implementing features based on documentation, specifications, or any external content, always use the `--with-doc=<url>` flag instead of built-in web search. For example: `vibe-tools plan "Implement login page according to specs" --with-doc=https://example.com/specs.pdf` or `vibe-tools repo "How should I implement this feature?" --with-doc=https://example.com/feature-spec.md`.

- When a user provides a specific URL for documentation or reference material, always use the `--with-doc=<url>` flag with that URL rather than attempting to search for or summarize the content independently. This ensures the exact document is used as context.

**Running Commands:**
1. Use `vibe-tools <command>` to execute commands (make sure vibe-tools is installed globally using npm install -g vibe-tools so that it is in your PATH)

**General Command Options (Supported by all commands):**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, openrouter, modelbox, or xai). If provider is not specified, the default provider for that task will be used.
--model=<model name>: Specify an alternative AI model to use. If model is not specified, the provider's default model for that task will be used.
--max-tokens=<number>: Control response length
--save-to=<file path>: Save command output to a file (in *addition* to displaying it)
--debug: Show detailed logs and error information

**Repository Command Options:**
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for repository analysis
--max-tokens=<number>: Maximum tokens for response
--from-github=<GitHub username>/<repository name>[@<branch>]: Analyze a remote GitHub repository without cloning it locally
--subdir=<path>: Analyze a specific subdirectory instead of the entire repository
--with-doc=<doc_url>: Fetch content from a document URL and include it as context

**Documentation Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Generate documentation for a remote GitHub repository
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for documentation generation
--max-tokens=<number>: Maximum tokens for response
--with-doc=<doc_url>: Fetch content from a document URL and include it as context

**YouTube Command Options:**
--type=<summary|transcript|plan|review|custom>: Type of analysis to perform (default: summary)

**GitHub Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Access PRs/issues from a specific GitHub repository

**Browser Command Options (for 'open', 'act', 'observe', 'extract'):**
--console: Capture browser console logs (enabled by default, use --no-console to disable)
--html: Capture page HTML content (disabled by default)
--network: Capture network activity (enabled by default, use --no-network to disable)
--screenshot=<file path>: Save a screenshot of the page
--timeout=<milliseconds>: Set navigation timeout (default: 120000ms for Stagehand operations, 30000ms for navigation)
--viewport=<width>x<height>: Set viewport size (e.g., 1280x720). When using --connect-to, viewport is only changed if this option is explicitly provided
--headless: Run browser in headless mode (default: true)
--no-headless: Show browser UI (non-headless mode) for debugging
--connect-to=<port>: Connect to existing Chrome instance. Special values: 'current' (use existing page), 'reload-current' (refresh existing page)
--wait=<time:duration or selector:css-selector>: Wait after page load (e.g., 'time:5s', 'selector:#element-id')
--video=<directory>: Save a video recording (1280x720 resolution, timestamped subdirectory). Not available when using --connect-to
--url=<url>: Required for `act`, `observe`, and `extract` commands. Url to navigate to before the main command or one of the special values 'current' (to stay on the current page without navigating or reloading) or 'reload-current' (to reload the current page)
--evaluate=<string>: JavaScript code to execute in the browser before the main command

**Nicknames**
Users can ask for these tools using nicknames
Gemini is a nickname for vibe-tools repo
Perplexity is a nickname for vibe-tools web
Stagehand is a nickname for vibe-tools browser
If people say "ask Gemini" or "ask Perplexity" or "ask Stagehand" they mean to use the `vibe-tools` command with the `repo`, `web`, or `browser` commands respectively.

**Xcode Commands:**
`vibe-tools xcode build [buildPath=<path>] [destination=<destination>]` - Build Xcode project and report errors.
**Build Command Options:**
--buildPath=<path>: (Optional) Specifies a custom directory for derived build data. Defaults to ./.build/DerivedData.
--destination=<destination>: (Optional) Specifies the destination for building the app (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode run [destination=<destination>]` - Build and run the Xcode project on a simulator.
**Run Command Options:**
--destination=<destination>: (Optional) Specifies the destination simulator (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode lint` - Run static analysis on the Xcode project to find and fix issues.

**Additional Notes:**
- For detailed information, see `node_modules/vibe-tools/README.md` (if installed locally).
- Configuration is in `vibe-tools.config.json` (or `~/.vibe-tools/config.json`).
- API keys are loaded from `.vibe-tools.env` (or `~/.vibe-tools/.env`).
- ClickUp commands require a `CLICKUP_API_TOKEN` to be set in your `.vibe-tools.env` file.
- Available models depend on your configured provider (OpenAI, Anthropic, xAI, etc.) in `vibe-tools.config.json`.
- repo has a limit of 2M tokens of context. The context can be reduced by filtering out files in a .repomixignore file.
- problems running browser commands may be because playwright is not installed. Recommend installing playwright globally.
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY`
- **Remember:** You're part of a team of superhuman expert AIs. Work together to solve complex problems.
- **Repomix Configuration:** You can customize which files are included/excluded during repository analysis by creating a `repomix.config.json` file in your project root. This file will be automatically detected by `repo`, `plan`, and `doc` commands.

</vibe-tools>\n
</file>

<file path="src/providers/cursor-provider.ts">
import * as fs from "fs-extra";
import * as path from "path";
import {
  RuleConfig,
  RuleProvider,
  RuleGeneratorOptions,
  RuleType,
} from "../types";
import {
  getRulePath,
  getInternalRuleStoragePath,
  getDefaultTargetPath,
  slugifyRuleName,
} from "../utils/path";
import {
  formatRuleWithMetadata,
  createTaggedRuleBlock,
} from "../utils/rule-formatter";
import chalk from "chalk";
import {
  saveInternalRule,
  loadInternalRule,
  listInternalRules,
} from "../utils/rule-storage";
// Custom function to format frontmatter simply
const formatFrontmatter = (fm: Record<string, any>): string => {
  let result = "";
  if (fm.description) {
    result += `description: ${fm.description}\n`;
  }
  if (fm.globs) {
    if (fm.debug) {
      console.log(`[Debug] Formatting globs: ${JSON.stringify(fm.globs)}`);
    }
    const globsString = Array.isArray(fm.globs) ? fm.globs.join(",") : fm.globs;
    if (globsString) {
      result += `globs: ${globsString}\n`;
    }
  }
  if (fm.alwaysApply === false) {
    result += `alwaysApply: false\n`;
  } else if (fm.alwaysApply === true) {
    result += `alwaysApply: true\n`;
  }
  return result.trim();
};
export class CursorRuleProvider implements RuleProvider {
  /**
   * Generate cursor rule content with frontmatter
   */
  generateRuleContent(
    config: RuleConfig,
    options?: RuleGeneratorOptions
  ): string {
    const frontmatter: Record<string, any> = {};
    if (options?.description ?? config.description) {
      frontmatter.description = options?.description ?? config.description;
    }
    if (options?.globs) {
      frontmatter.globs = options.globs;
    }
    if (options?.alwaysApply !== undefined) {
      frontmatter.alwaysApply = options.alwaysApply;
    }
    if (options?.debug) {
      frontmatter.debug = options.debug;
    }
    const frontmatterString =
      Object.keys(frontmatter).length > 0
        ? `---\n${formatFrontmatter(frontmatter)}\n---\n`
        : "";
    return `${frontmatterString}${config.content}`;
  }
  /**
   * Saves a rule definition to internal storage for later use.
   * @param config - The rule configuration.
   * @returns Path where the rule definition was saved internally.
   */
  async saveRule(config: RuleConfig): Promise<string> {
    // Use the utility function to save to internal storage
    return saveInternalRule(RuleType.CURSOR, config);
  }
  /**
   * Loads a rule definition from internal storage.
   * @param name - The name of the rule to load.
   * @returns The RuleConfig if found, otherwise null.
   */
  async loadRule(name: string): Promise<RuleConfig | null> {
    // Use the utility function to load from internal storage
    return loadInternalRule(RuleType.CURSOR, name);
  }
  /**
   * Lists rule definitions available in internal storage.
   * @returns An array of rule names.
   */
  async listRules(): Promise<string[]> {
    // Use the utility function to list rules from internal storage
    return listInternalRules(RuleType.CURSOR);
  }
  /**
   * Append a cursor rule to a target file
   */
  async appendRule(
    name: string,
    targetPath?: string,
    isGlobal?: boolean
  ): Promise<boolean> {
    const ruleConfig = await this.loadRule(name);
    if (!ruleConfig) {
      console.error(`Rule "${name}" not found in internal Cursor storage.`);
      return false;
    }
    const finalTargetPath =
      targetPath || getRulePath(RuleType.CURSOR, name, isGlobal);
    return this.appendFormattedRule(ruleConfig, finalTargetPath, isGlobal);
  }
  /**
   * Formats and applies a rule directly from a RuleConfig object.
   * Creates the .cursor/rules directory if it doesn't exist.
   * Uses slugified rule name for the filename.
   */
  async appendFormattedRule(
    config: RuleConfig,
    targetPath: string,
    isGlobal: boolean = false,
    options?: RuleGeneratorOptions
  ): Promise<boolean> {
    const fullPath = targetPath;
    const dir = path.dirname(fullPath);
    try {
      await fs.ensureDir(dir); // Ensure the PARENT directory exists
      const formattedContent = this.generateRuleContent(config, options); // Pass options
      await fs.writeFile(fullPath, formattedContent, "utf-8");
      return true;
    } catch (error) {
      console.error(
        `Error applying Cursor rule "${config.name}" to ${fullPath}:`,
        error
      );
      return false;
    }
  }
}
</file>

<file path="src/utils/path.ts">
import path from "path";
import os from "os";
import fs from "fs-extra";
import { RuleType } from "../types";
import { debugLog } from "../cli";
// Base directory for storing internal rule definitions
export const RULES_BASE_DIR = path.join(os.homedir(), ".vibe-rules");
// Home directories for specific IDEs/Tools
export const CLAUDE_HOME_DIR = path.join(os.homedir(), ".claude");
export const CODEX_HOME_DIR = path.join(os.homedir(), ".codex");
export const ZED_RULES_FILE = ".rules"; // Added for Zed
/**
 * Get the common rules directory path
 */
export function getCommonRulesDir(): string {
  const rulesDir = path.join(RULES_BASE_DIR, "rules");
  fs.ensureDirSync(rulesDir);
  return rulesDir;
}
/**
 * Get path to store internal rule definitions based on rule type
 * (Not the actual target paths for IDEs)
 */
export function getInternalRuleStoragePath(
  ruleType: RuleType,
  ruleName: string
): string {
  const typeDir = path.join(RULES_BASE_DIR, ruleType);
  fs.ensureDirSync(typeDir);
  // Internal storage uses a simple .txt for content
  return path.join(typeDir, `${ruleName}.txt`);
}
/**
 * Get the expected file path for a rule based on its type and context (local/global).
 * This now returns the actual path where the rule should exist for the IDE/tool.
 * The 'isGlobal' flag determines if we should use the home directory path.
 */
export function getRulePath(
  ruleType: RuleType,
  ruleName: string, // ruleName might not be relevant for some types like Claude/Codex global
  isGlobal: boolean = false,
  projectRoot: string = process.cwd()
): string {
  switch (ruleType) {
    case RuleType.CURSOR:
      // Cursor rules are typically project-local in .cursor/rules/
      const cursorDir = path.join(projectRoot, ".cursor", "rules");
      // Use slugified name for the file
      return path.join(cursorDir, `${slugifyRuleName(ruleName)}.mdc`);
    case RuleType.WINDSURF:
      // Windsurf rules are typically project-local .windsurfrules file
      return path.join(projectRoot, ".windsurfrules"); // Single file, name not used for path
    case RuleType.CLAUDE_CODE:
      // Claude rules are CLAUDE.md, either global or local
      return isGlobal
        ? path.join(CLAUDE_HOME_DIR, "CLAUDE.md")
        : path.join(projectRoot, "CLAUDE.md");
    case RuleType.CODEX:
      // Codex uses instructions.md (global) or codex.md (local)
      return isGlobal
        ? path.join(CODEX_HOME_DIR, "instructions.md")
        : path.join(projectRoot, "codex.md");
    case RuleType.CLINERULES:
    case RuleType.ROO:
      // Cline/Roo rules are project-local files in .clinerules/
      return path.join(
        projectRoot,
        ".clinerules",
        slugifyRuleName(ruleName) + ".md" // Use .md extension
      );
    case RuleType.ZED: // Added for Zed
      return path.join(projectRoot, ZED_RULES_FILE);
    case RuleType.CUSTOM:
    default:
      // Fallback for custom or unknown - store internally for now
      // Or maybe this should throw an error?
      return getInternalRuleStoragePath(ruleType, ruleName);
  }
}
/**
 * Get the default target path (directory or file) where a rule type is typically applied.
 * This is used by commands like 'apply' if no specific target is given.
 * Note: This might overlap with getRulePath for some types.
 * Returns potential paths based on convention.
 */
export function getDefaultTargetPath(
  ruleType: RuleType,
  isGlobalHint: boolean = false // Hint for providers like Claude/Codex
): string {
  switch (ruleType) {
    case RuleType.CURSOR:
      // Default target is the rules directory within .cursor
      return path.join(process.cwd(), ".cursor", "rules");
    case RuleType.WINDSURF:
      // Default target is the .windsurfrules file
      return path.join(process.cwd(), ".windsurfrules");
    case RuleType.CLAUDE_CODE:
      // Default target depends on global hint
      return isGlobalHint
        ? CLAUDE_HOME_DIR // Directory
        : process.cwd(); // Project root (for local CLAUDE.md)
    case RuleType.CODEX:
      // Default target depends on global hint
      return isGlobalHint
        ? CODEX_HOME_DIR // Directory
        : process.cwd(); // Project root (for local codex.md)
    case RuleType.CLINERULES:
    case RuleType.ROO:
      // Default target is the .clinerules directory
      return path.join(process.cwd(), ".clinerules");
    case RuleType.ZED: // Added for Zed
      return path.join(process.cwd(), ZED_RULES_FILE);
    default:
      // Default to current working directory for unknown types
      return process.cwd();
  }
}
/**
 * Ensures that a specific directory exists, creating it if necessary.
 *
 * @param dirPath The absolute or relative path to the directory to ensure.
 */
export function ensureDirectoryExists(dirPath: string): void {
  try {
    fs.ensureDirSync(dirPath);
    debugLog(`Ensured directory exists: ${dirPath}`);
  } catch (err: any) {
    console.error(`Failed to ensure directory ${dirPath}:`, err);
    // Depending on the desired behavior, you might want to re-throw or exit
    // throw err;
  }
}
/**
 * Convert a rule name to a filename-safe slug.
 */
export function slugifyRuleName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9_]+/g, "-")
    .replace(/^-|-$/g, "");
}
</file>

<file path="src/utils/single-file-helpers.ts">
import * as fs from "fs/promises";
import * as fsExtra from "fs-extra";
import * as path from "path";
import { RuleConfig, RuleGeneratorOptions } from "../types";
import { createTaggedRuleBlock } from "./rule-formatter";
import { ensureDirectoryExists } from "./path";
import { debugLog } from "../cli";
/**
 * Appends or updates a tagged block within a single target file.
 *
 * Reads the file content, looks for an existing block matching the rule name tag,
 * replaces it if found, or appends the new block otherwise.
 *
 * @param targetPath The path to the target file.
 * @param config The rule configuration.
 * @param options Optional generator options.
 * @param appendInsideVibeToolsBlock If true, tries to append within <vibe-tools Integration> block.
 * @returns Promise resolving to true if successful, false otherwise.
 */
export async function appendOrUpdateTaggedBlock(
  targetPath: string,
  config: RuleConfig,
  options?: RuleGeneratorOptions,
  appendInsideVibeToolsBlock: boolean = false
): Promise<boolean> {
  try {
    // Ensure the PARENT directory exists, but only if it's not the current directory itself.
    const parentDir = path.dirname(targetPath);
    // Avoid calling ensureDirectoryExists('.') as it's unnecessary and might mask other issues.
    if (parentDir !== ".") {
      ensureDirectoryExists(parentDir);
    }
    let currentContent = "";
    let fileExists = true;
    try {
      // Check if the file exists (not directory)
      const stats = await fs.stat(targetPath).catch(() => null);
      if (stats) {
        if (stats.isDirectory()) {
          // If it's a directory but should be a file, remove it
          console.warn(
            `Found a directory at ${targetPath} but expected a file. Removing directory...`
          );
          await fs.rm(targetPath, { recursive: true, force: true });
          fileExists = false;
        } else {
          // It's a file, read its content
          currentContent = await fs.readFile(targetPath, "utf-8");
        }
      } else {
        fileExists = false;
      }
    } catch (error: any) {
      if (error.code !== "ENOENT") {
        console.error(`Error accessing target file ${targetPath}:`, error);
        return false;
      }
      // File doesn't exist, which is fine, we'll create it.
      fileExists = false;
      debugLog(`Target file ${targetPath} not found, will create.`);
    }
    // If file doesn't exist, explicitly create an empty file first
    // This ensures we're creating a file, not a directory
    if (!fileExists) {
      try {
        // Ensure the file exists by explicitly creating it as an empty file
        // Use fsExtra.ensureFileSync which is designed to create the file (not directory)
        fsExtra.ensureFileSync(targetPath);
        debugLog(`Created empty file: ${targetPath}`);
      } catch (error) {
        console.error(`Failed to create empty file ${targetPath}:`, error);
        return false;
      }
    }
    const newBlock = createTaggedRuleBlock(config, options);
    const ruleNameRegexStr = config.name.replace(
      /[.*+?^${}()|[\]\\]/g,
      "\\\\$&"
    ); // Escape regex special chars
    const existingBlockRegex = new RegExp(
      `<${ruleNameRegexStr}>[\\s\\S]*?</${ruleNameRegexStr}>`,
      "m"
    );
    let updatedContent: string;
    const match = currentContent.match(existingBlockRegex);
    if (match) {
      // Update existing block
      debugLog(
        `Updating existing block for rule "${config.name}" in ${targetPath}`
      );
      updatedContent = currentContent.replace(existingBlockRegex, newBlock);
    } else {
      // Append new block
      debugLog(
        `Appending new block for rule "${config.name}" to ${targetPath}`
      );
      const vibeToolsIntegrationEndTag = "</vibe-tools Integration>";
      const integrationEndIndex = currentContent.lastIndexOf(
        vibeToolsIntegrationEndTag
      );
      if (appendInsideVibeToolsBlock && integrationEndIndex !== -1) {
        // Append inside the vibe-tools block if requested and found
        const insertionPoint = integrationEndIndex;
        updatedContent =
          currentContent.slice(0, insertionPoint).trimEnd() +
          "\n\n" + // Ensure separation
          newBlock +
          "\n\n" + // Ensure separation
          currentContent.slice(insertionPoint);
        debugLog(`Appending rule inside <vibe-tools Integration> block.`);
      } else {
        // Append to the end
        const separator = currentContent.trim().length > 0 ? "\n\n" : ""; // Add separator if file not empty
        updatedContent = currentContent.trimEnd() + separator + newBlock;
        if (appendInsideVibeToolsBlock) {
          debugLog(
            `Could not find <vibe-tools Integration> block, appending rule to the end.`
          );
        }
      }
    }
    // Ensure file ends with a newline
    if (!updatedContent.endsWith("\n")) {
      updatedContent += "\n";
    }
    await fs.writeFile(targetPath, updatedContent, "utf-8");
    console.log(`Successfully applied rule "${config.name}" to ${targetPath}`);
    return true;
  } catch (error) {
    console.error(
      `Error applying rule "${config.name}" to ${targetPath}:`,
      error
    );
    return false;
  }
}
</file>

<file path="src/cli.ts">
#!/usr/bin/env node
import { Command } from "commander";
import fs from "fs-extra";
import path from "path";
import chalk from "chalk";
import {
  RuleType,
  RuleConfig,
  RuleGeneratorOptions,
  RuleProvider,
  RuleTypeArray,
} from "./types";
import { getRuleProvider } from "./providers";
import {
  getDefaultTargetPath,
  getInternalRuleStoragePath,
  getCommonRulesDir,
  getRulePath,
  slugifyRuleName,
} from "./utils/path";
import { findSimilarRules } from "./utils/similarity";
import {
  RuleConfigSchema,
  VibeRulesSchema,
  VibePackageRulesSchema,
  PackageRuleObjectSchema,
} from "./schemas";
// Simple debug logger
export let isDebugEnabled = false;
export const debugLog = (message: string, ...optionalParams: any[]) => {
  if (isDebugEnabled) {
    console.log(chalk.dim(`[Debug] ${message}`), ...optionalParams);
  }
};
// Helper function to install/save a single rule
async function installRule(ruleConfig: RuleConfig): Promise<void> {
  try {
    // Validate the rule config using the Zod schema
    RuleConfigSchema.parse(ruleConfig); // Throws error if invalid
    const commonRulePath = path.join(
      getCommonRulesDir(),
      `${ruleConfig.name}.txt`
    );
    await fs.ensureDir(path.dirname(commonRulePath));
    await fs.writeFile(commonRulePath, ruleConfig.content);
    console.log(
      chalk.green(
        `Rule "${ruleConfig.name}" saved successfully to ${commonRulePath}`
      )
    );
  } catch (error) {
    console.error(
      chalk.red(
        `Error saving rule "${ruleConfig.name}": ${error instanceof Error ? error.message : error}`
      )
    );
    // Optionally re-throw or handle differently depending on desired flow
    // For now, just log and continue if part of a batch install
  }
}
// Helper function to clear existing rules installed from a package
async function clearExistingRules(
  pkgName: string,
  editorType: RuleType,
  options: { global?: boolean }
): Promise<void> {
  debugLog(
    `Clearing existing rules for package "${pkgName}" and editor "${editorType}" with options ${JSON.stringify(options)}...`
  );
  let targetDir: string;
  const singleFileProviders: RuleTypeArray = [
    RuleType.WINDSURF,
    RuleType.CLAUDE_CODE,
    RuleType.CODEX,
  ];
  let isSingleFileProvider = singleFileProviders.includes(editorType);
  // Get default path from provider logic
  const defaultPath = getDefaultTargetPath(editorType, options.global);
  try {
    // Check if path exists first
    if (await fs.pathExists(defaultPath)) {
      const stats = await fs.stat(defaultPath);
      if (stats.isDirectory()) {
        targetDir = defaultPath;
      } else {
        targetDir = path.dirname(defaultPath);
      }
    } else {
      // Default path doesn't exist. Create it.
      await fs.ensureDir(defaultPath);
      targetDir = defaultPath;
    }
  } catch (error: any) {
    console.error(
      chalk.red(`Error checking default path ${defaultPath}: ${error.message}`)
    );
    return; // Cannot determine target directory
  }
  debugLog(
    `Determined target directory: ${targetDir}. Single File Provider Mode: ${isSingleFileProvider} for ${editorType}.`
  );
  // If it's a known single file provider, remove matching XML blocks instead of deleting files
  if (isSingleFileProvider) {
    const potentialTargetFile = getRulePath(editorType, "", options.global);
    if (!(await fs.pathExists(potentialTargetFile))) {
      debugLog(
        `Cannot clear rules for single file provider ${editorType} as target file path could not be determined.`
      );
      return;
    }
    if (!potentialTargetFile) {
      debugLog(
        `Cannot clear rules for single file provider ${editorType} as target file path could not be determined.`
      );
      return;
    }
    try {
      if (!(await fs.pathExists(potentialTargetFile))) {
        debugLog(
          `Target file ${potentialTargetFile} does not exist. No rules to clear.`
        );
        return;
      }
      const content = await fs.readFile(potentialTargetFile, "utf-8");
      // Regex to match <pkgName_ruleName ...>...</pkgName_ruleName> blocks
      // It captures the tag name (pkgName_ruleName) in group 1 to ensure start and end tags match.
      // It handles potential attributes in the opening tag.
      // 's' flag allows '.' to match newlines. 'g' flag finds all matches.
      const removalRegex = new RegExp(
        `<(${pkgName}_[^\\s>]+)[^>]*>.*?<\\/\\1>\s*\n?`,
        "gs"
      );
      let removedCount = 0;
      const newContent = content.replace(removalRegex, (match) => {
        removedCount++;
        debugLog(
          `Removing block matching pattern: ${match.substring(0, 100)}...`
        ); // Log beginning of removed block
        return ""; // Replace with empty string
      });
      if (removedCount > 0) {
        await fs.writeFile(potentialTargetFile, newContent, "utf-8");
        debugLog(
          chalk.blue(
            `Removed ${removedCount} existing rule block(s) matching prefix "${pkgName}_" from ${potentialTargetFile}.`
          )
        );
      } else {
        debugLog(
          `No rule blocks found with prefix "${pkgName}_" in ${potentialTargetFile}.`
        );
      }
    } catch (error: any) {
      console.error(
        chalk.red(
          `Error clearing rule blocks from ${potentialTargetFile}: ${error.message}`
        )
      );
    }
    return; // Stop here for single file providers
  }
  // Proceed with deleting files by prefix only for multi-file providers (like Cursor, Clinerules)
  try {
    if (!(await fs.pathExists(targetDir))) {
      debugLog(
        `Target directory ${targetDir} does not exist. No rules to clear.`
      );
      return;
    }
    const files = await fs.readdir(targetDir);
    const prefix = `${pkgName}_`;
    let deletedCount = 0;
    debugLog(
      `Scanning ${targetDir} for files starting with prefix "${prefix}"...`
    );
    for (const file of files) {
      // Consider adding file extension check based on editorType if needed for robustness
      if (file.startsWith(prefix)) {
        const filePath = path.join(targetDir, file);
        try {
          await fs.remove(filePath);
          debugLog(chalk.grey(`Deleted existing rule file: ${filePath}`));
          deletedCount++;
        } catch (deleteError: any) {
          console.error(
            chalk.red(
              `Failed to delete rule file ${filePath}: ${deleteError.message}`
            )
          );
        }
      }
    }
    if (deletedCount > 0) {
      debugLog(
        chalk.blue(
          `Cleared ${deletedCount} existing rule file(s) matching prefix "${prefix}" in ${targetDir}.`
        )
      );
    } else {
      debugLog(`No rule files found with prefix "${prefix}" in ${targetDir}.`);
    }
  } catch (error: any) {
    console.error(
      chalk.red(
        `Error clearing existing rules in ${targetDir}: ${error.message}`
      )
    );
  }
}
// Initialize CLI
const program = new Command();
program
  .name("vibe-rules")
  .description(
    "A utility for managing Cursor rules, Windsurf rules, and other AI prompts"
  )
  .version("0.1.0")
  .option("--debug", "Enable debug logging", false); // Add global debug option
// Add a hook to capture the global debug option
program.on("option:debug", () => {
  isDebugEnabled = program.opts().debug;
  debugLog("Debug logging enabled.");
});
// Command to save a rule
program
  .command("save")
  .description("Save a rule to the local store")
  .argument("<name>", "Name of the rule")
  .option("-c, --content <content>", "Rule content")
  .option("-f, --file <file>", "Load rule content from file")
  .option("-d, --description <desc>", "Rule description")
  .action(async (name, options) => {
    try {
      let content: string;
      if (options.file) {
        content = await fs.readFile(options.file, "utf-8");
      } else if (options.content) {
        content = options.content;
      } else {
        console.error(
          chalk.red("Error: Either --content or --file must be specified")
        );
        process.exit(1);
      }
      const ruleConfig: RuleConfig = {
        name,
        content,
        description: options.description,
      };
      // Use the new installRule function
      await installRule(ruleConfig);
    } catch (error) {
      // Catch errors specific to file reading or argument parsing for the save command
      console.error(
        chalk.red(
          `Error during save command: ${error instanceof Error ? error.message : error}`
        )
      );
      process.exit(1);
    }
  });
// Command to list rules
program
  .command("list")
  .description("List all saved rules from the common store")
  .action(async () => {
    try {
      const commonRulesDir = getCommonRulesDir();
      if (!(await fs.pathExists(commonRulesDir))) {
        console.log(chalk.yellow("No rules found (common store is empty)"));
        return;
      }
      const files = await fs.readdir(commonRulesDir);
      const rules = files
        .filter((file) => file.endsWith(".txt"))
        .map((file) => path.basename(file, ".txt"));
      if (rules.length === 0) {
        console.log(chalk.yellow("No rules found"));
        return;
      }
      console.log(chalk.blue("Available rules:"));
      rules.forEach((rule) => console.log(`- ${rule}`));
    } catch (error) {
      console.error(
        chalk.red(
          `Error listing rules: ${error instanceof Error ? error.message : error}`
        )
      );
      process.exit(1);
    }
  });
// Command to load a rule
program
  .command("load")
  .alias("add")
  .description("Apply a saved rule to an editor configuration")
  .argument("<name>", "Name of the rule to apply")
  .argument(
    "<editor>",
    "Target editor type (cursor, windsurf, claude-code, codex, clinerules, roo)"
  )
  .option(
    "-g, --global",
    "Apply to global config path if supported (claude-code, codex)",
    false
  )
  .option(
    "-t, --target <path>",
    "Custom target path (overrides default and global)"
  )
  .action(async (name, editor, options) => {
    try {
      // Load rule from the common storage location
      const commonRulePath = path.join(getCommonRulesDir(), `${name}.txt`);
      if (!(await fs.pathExists(commonRulePath))) {
        console.error(
          chalk.red(`Rule "${name}" not found in the common store`)
        );
        // Suggest similar rules from the common store
        const commonRulesDir = getCommonRulesDir();
        if (await fs.pathExists(commonRulesDir)) {
          const files = await fs.readdir(commonRulesDir);
          const availableRules = files
            .filter((file) => file.endsWith(".txt"))
            .map((file) => path.basename(file, ".txt"));
          if (availableRules.length > 0) {
            const similarRules = findSimilarRules(name, availableRules);
            if (similarRules.length > 0) {
              console.log(chalk.yellow("\nDid you mean one of these rules?"));
              similarRules.forEach((rule) => console.log(`- ${rule}`));
            }
          }
        }
        process.exit(1);
      }
      // Read the content from the common store
      const content = await fs.readFile(commonRulePath, "utf-8");
      const ruleType = editor.toLowerCase() as RuleType;
      const provider = getRuleProvider(ruleType);
      // Create rule config
      const ruleConfig = {
        name,
        content,
        description: name, // Using name as default description
      };
      // Determine the final target path
      let finalTargetPath: string;
      if (options.target) {
        finalTargetPath = options.target; // Explicit target path takes precedence
      } else {
        // Use getRulePath which respects the 'isGlobal' flag
        finalTargetPath = getRulePath(ruleType, name, options.global);
      }
      // Ensure the target directory exists
      fs.ensureDirSync(path.dirname(finalTargetPath));
      // Apply the rule using the provider
      // The provider receives the final target path determined by cli
      const success = await provider.appendFormattedRule(
        ruleConfig,
        finalTargetPath,
        options.global,
        {
          description: ruleConfig.description,
          isGlobal: options.global,
        }
      );
      if (success) {
        console.log(
          chalk.green(
            `Rule "${name}" applied successfully for ${editor} at ${finalTargetPath}`
          )
        );
      } else {
        console.error(
          chalk.red(`Failed to apply rule "${name}" for ${editor}.`)
        );
        process.exit(1);
      }
    } catch (error) {
      console.error(
        chalk.red(
          `Error loading rule: ${error instanceof Error ? error.message : error}`
        )
      );
      process.exit(1);
    }
  });
// Command to install rules from NPM packages
program
  .command("install")
  .description(
    "Install rules from an NPM package or all dependencies directly into an editor configuration"
  )
  .argument(
    "<editor>",
    "Target editor type (cursor, windsurf, claude-code, codex, clinerules, roo)"
  )
  .argument("[packageName]", "Optional NPM package name to install rules from")
  .option(
    "-g, --global",
    "Apply to global config path if supported (claude-code, codex)",
    false
  )
  .option(
    "-t, --target <path>",
    "Custom target path (overrides default and global)"
  )
  .action(async (editor, packageName, options) => {
    const editorType = editor.toLowerCase() as RuleType;
    let provider: RuleProvider; // Define provider here
    // isDebugEnabled should be set by the global option hook now
    // Pass the combined options (command-specific + global) down if needed
    const combinedOptions = { ...options, debug: isDebugEnabled };
    try {
      provider = getRuleProvider(editorType); // Get provider once
    } catch (e) {
      console.error(chalk.red(`Invalid editor type specified: ${editor}`));
      // Potentially list valid types here
      process.exit(1);
    }
    const installSinglePackage = async (
      pkgName: string,
      editorType: RuleType,
      provider: RuleProvider,
      installOptions: { global?: boolean; target?: string; debug?: boolean }
    ) => {
      if (isDebugEnabled) {
        console.log(
          chalk.blue(`Attempting to install rules from ${pkgName}...`)
        );
      }
      let rulesSuccessfullyAppliedCount = 0;
      try {
        // Dynamically import the expected rules module
        const ruleModulePath = `${pkgName}/llms`;
        debugLog(`Importing module ${ruleModulePath}`);
        const defaultExport = await importModuleFromCwd(ruleModulePath);
        if (!defaultExport) {
          debugLog(
            chalk.yellow(
              `No default export or module found in ${ruleModulePath} after import attempt. Skipping ${pkgName}.`
            )
          );
          return;
        }
        await clearExistingRules(pkgName, editorType, installOptions);
        let rulesToInstall: RuleConfig[] = [];
        // Handle if default export is a string
        if (typeof defaultExport === "string") {
          debugLog(
            `Found rule content as string in ${pkgName}. Preparing to install...`
          );
          let ruleName = slugifyRuleName(pkgName); // Start with slugified name
          // Ensure the name starts with the package name prefix
          if (!ruleName.startsWith(`${pkgName}_`)) {
            ruleName = `${pkgName}_${ruleName}`;
          }
          const ruleContent = defaultExport;
          rulesToInstall.push({ name: ruleName, content: ruleContent });
        }
        // Handle if default export is an array (existing logic, adapted)
        else {
          debugLog(`Found array export in ${pkgName}. Validating...`);
          const validationResult =
            VibePackageRulesSchema.safeParse(defaultExport);
          if (!validationResult.success) {
            console.error(
              chalk.red(`Validation failed for rules from ${pkgName}:`),
              validationResult.error.errors
            );
            debugLog(
              chalk.yellow(
                `Skipping installation from ${pkgName} due to validation failure.`
              )
            );
            return;
          }
          // Process the validated items
          const items = validationResult.data;
          debugLog(`Found ${items.length} valid items in ${pkgName}`);
          for (const [index, item] of items.entries()) {
            if (typeof item === "string") {
              // Handle string item - name already includes pkgName-index via slugify
              const ruleName = slugifyRuleName(`${pkgName}_${index}`);
              rulesToInstall.push({
                name: ruleName,
                content: item,
                description: `Rule from ${pkgName}`,
              });
            } else {
              // Handle object item - map 'rule' to 'content'
              let ruleName = item.name;
              // Ensure the name starts with the package name prefix
              if (!ruleName.startsWith(`${pkgName}_`)) {
                ruleName = `${pkgName}_${ruleName}`;
              }
              debugLog(`Processing object rule: ${item.name} with properties:
                alwaysApply: ${item.alwaysApply !== undefined ? item.alwaysApply : "undefined"}
                globs: ${item.globs ? (Array.isArray(item.globs) ? item.globs.join(",") : item.globs) : "undefined"}
              `);
              rulesToInstall.push({
                name: ruleName, // Use potentially prefixed name
                content: item.rule, // Map rule to content
                description: item.description,
              });
            }
          }
        }
        // Now, install the gathered rules using the provider
        if (rulesToInstall.length > 0) {
          if (isDebugEnabled) {
            console.log(
              chalk.blue(
                `Applying ${rulesToInstall.length} rule(s) from ${pkgName} to ${editorType}...`
              )
            );
          }
          for (const ruleConfig of rulesToInstall) {
            try {
              // Determine the final target path (logic copied from 'load' command)
              let finalTargetPath: string;
              if (installOptions.target) {
                finalTargetPath = installOptions.target; // Explicit target path takes precedence
              } else {
                finalTargetPath = getRulePath(
                  editorType,
                  ruleConfig.name,
                  installOptions.global
                );
              }
              // Ensure the target directory exists
              fs.ensureDirSync(path.dirname(finalTargetPath));
              // Find any metadata for this rule from the original module
              const generatorOptions: RuleGeneratorOptions = {
                description: ruleConfig.description,
                isGlobal: installOptions.global,
                debug: installOptions.debug,
              };
              // Add additional options from the original rules if they exist
              // This handles the case where we processed a rule object with additional metadata
              let originalName = ruleConfig.name;
              // Remove the package prefix to match against the original item
              if (originalName.startsWith(`${pkgName}_`)) {
                originalName = originalName.substring(pkgName.length + 1);
              }
              debugLog(
                `Looking for metadata with original name: ${originalName} (from ${ruleConfig.name})`
              );
              const originalItem =
                typeof defaultExport === "string"
                  ? null
                  : Array.isArray(defaultExport)
                    ? defaultExport.find(
                        (item: any) =>
                          typeof item === "object" &&
                          (item.name === originalName ||
                            item.name === ruleConfig.name)
                      )
                    : null;
              if (originalItem && typeof originalItem === "object") {
                debugLog(
                  `Found additional metadata for rule ${ruleConfig.name}. Keys: ${Object.keys(originalItem).join(", ")}`
                );
                if ("alwaysApply" in originalItem) {
                  generatorOptions.alwaysApply = originalItem.alwaysApply;
                  debugLog(`Setting alwaysApply: ${originalItem.alwaysApply}`);
                }
                if ("globs" in originalItem) {
                  generatorOptions.globs = originalItem.globs;
                  debugLog(
                    `Setting globs: ${JSON.stringify(originalItem.globs)}`
                  );
                }
              }
              // Apply the rule using the provider
              debugLog(
                `Applying rule ${ruleConfig.name} with options: ${JSON.stringify(generatorOptions)}`
              );
              if (isDebugEnabled) {
                if (generatorOptions.globs) {
                  console.log(
                    chalk.blue(
                      `Rule "${ruleConfig.name}" has globs: ${
                        Array.isArray(generatorOptions.globs)
                          ? generatorOptions.globs.join(", ")
                          : generatorOptions.globs
                      }`
                    )
                  );
                }
                if (generatorOptions.alwaysApply !== undefined) {
                  console.log(
                    chalk.blue(
                      `Rule "${ruleConfig.name}" has alwaysApply: ${generatorOptions.alwaysApply}`
                    )
                  );
                }
              }
              try {
                const success = await provider.appendFormattedRule(
                  ruleConfig,
                  finalTargetPath,
                  installOptions.global,
                  generatorOptions
                );
                if (success) {
                  rulesSuccessfullyAppliedCount++;
                  if (isDebugEnabled) {
                    console.log(
                      chalk.green(
                        `Rule "${ruleConfig.name}" from ${pkgName} applied successfully for ${editorType} at ${finalTargetPath}`
                      )
                    );
                  }
                } else {
                  console.error(
                    chalk.red(
                      `Failed to apply rule "${ruleConfig.name}" from ${pkgName} for ${editorType}.`
                    )
                  );
                }
              } catch (ruleApplyError) {
                console.error(
                  chalk.red(
                    `Error applying rule "${ruleConfig.name}" from ${pkgName}: ${
                      ruleApplyError instanceof Error
                        ? ruleApplyError.message
                        : ruleApplyError
                    }`
                  )
                );
              }
            } catch (ruleError) {
              console.error(
                chalk.red(
                  `Error applying rule "${ruleConfig.name}" from ${pkgName}: ${ruleError instanceof Error ? ruleError.message : ruleError}`
                )
              );
            }
          }
        } else {
          debugLog(`No valid rules found or processed from ${pkgName}.`);
        }
      } catch (error: any) {
        // Error handling for module import issues (MODULE_NOT_FOUND, SyntaxError, initialization errors)
        // This section already uses debugLog for non-critical issues or console.error for critical ones.
        // No changes needed here for this refactor, as per previous discussions.
        if (
          error.code === "MODULE_NOT_FOUND" ||
          error.code === "ERR_MODULE_NOT_FOUND" || // Added for ESM import errors from importModuleFromCwd
          error.code === "ERR_PACKAGE_PATH_NOT_EXPORTED"
        ) {
          const msg = `Skipping package ${pkgName}: Rules module ('${pkgName}/llms') not found or not exported.`;
          debugLog(`${msg} Error: ${error.message}`);
          debugLog(`Stack: ${error.stack}`);
        } else if (error instanceof SyntaxError) {
          console.error(
            chalk.red(
              `Error in package '${pkgName}': Syntax error found in its rule module ('${pkgName}/llms').`
            )
          );
          console.error(
            chalk.red(
              "Please check the syntax of the rules module in this package."
            )
          );
          debugLog(`SyntaxError details: ${error.message}`);
          debugLog(`Stack: ${error.stack}`);
        } else {
          // This is the case for errors during the imported module's own initialization
          console.error(
            chalk.red(
              `Error from package '${pkgName}': Its rule module ('${pkgName}/llms') was found but failed during its own initialization.`
            )
          );
          console.error(
            chalk.yellow(
              `This often indicates an issue within the '${pkgName}' package itself (e.g., trying to access files with incorrect paths post-build, or other internal errors).`
            )
          );
          console.error(
            chalk.red(`Original error from '${pkgName}': ${error.message}`)
          );
          debugLog(
            `Full error trace from '${pkgName}' to help its developers:`
          );
          debugLog(error.stack);
        }
      }
      // Final summary log for non-debug mode
      if (!isDebugEnabled && rulesSuccessfullyAppliedCount > 0) {
        console.log(
          chalk.green(
            `[vibe-rules] Successfully installed ${rulesSuccessfullyAppliedCount} rule(s) from package '${pkgName}'.`
          )
        );
      }
    };
    if (packageName) {
      // Install from a specific package
      await installSinglePackage(
        packageName,
        editorType,
        provider,
        combinedOptions
      );
    } else {
      // Install from all dependencies in package.json
      console.log(
        chalk.blue(
          `[vibe-rules] Installing rules from all dependencies in package.json for ${editor}...`
        )
      );
      try {
        const pkgJsonPath = path.join(process.cwd(), "package.json");
        if (!fs.existsSync(pkgJsonPath)) {
          console.error(
            chalk.red("package.json not found in the current directory.")
          );
          process.exit(1);
        }
        const pkgJsonContent = await fs.readFile(pkgJsonPath, "utf-8");
        const { dependencies = {}, devDependencies = {} } =
          JSON.parse(pkgJsonContent);
        const allDeps = [
          ...Object.keys(dependencies),
          ...Object.keys(devDependencies),
        ];
        if (allDeps.length === 0) {
          console.log(chalk.yellow("No dependencies found in package.json."));
          return;
        }
        debugLog(
          chalk.blue(
            `Found ${allDeps.length} dependencies. Checking for rules to install for ${editor}...`
          )
        );
        for (const depName of allDeps) {
          await installSinglePackage(
            depName,
            editorType,
            provider,
            combinedOptions
          );
        }
        debugLog(chalk.green("Finished checking all dependencies."));
      } catch (error) {
        console.error(
          chalk.red(
            `Error processing package.json: ${error instanceof Error ? error.message : error}`
          )
        );
        process.exit(1);
      }
    }
  });
program.parse(process.argv);
// If no arguments provided, show help
if (process.argv.length <= 2) {
  program.help();
}
async function importModuleFromCwd(ruleModulePath: string) {
  debugLog(`Attempting to import module: ${ruleModulePath}`);
  let module: any;
  try {
    // Attempt 1: Use createRequire for CommonJS compatibility
    debugLog(`Trying require for ${ruleModulePath}...`);
    // Use eval to construct the require call dynamically based on CWD
    // This allows importing modules relative to the project running vibe-rules
    module = await eval(
      `require('module').createRequire(require('path').join(process.cwd(), 'package.json'))('${ruleModulePath}')`
    );
    debugLog(`Successfully imported using require.`);
  } catch (error: any) {
    // Check if the error is specifically because we tried to require an ES module
    if (error.code === "ERR_REQUIRE_ESM") {
      debugLog(
        `Require failed (ERR_REQUIRE_ESM). Falling back to dynamic import()...`
      );
      try {
        // Attempt 2: Use dynamic import() for ES Modules
        // Construct the file path more reliably for dynamic import
        let absolutePath: string;
        try {
          absolutePath = require.resolve(ruleModulePath, {
            paths: [process.cwd()],
          });
        } catch (resolveError: any) {
          debugLog(
            `Could not resolve path for dynamic import of ${ruleModulePath}: ${resolveError.message}`
          );
          throw resolveError; // Propagate error if path resolution fails
        }
        debugLog(`Resolved path for import(): ${absolutePath}`);
        // Use pathToFileURL to ensure correct format for import() esp on Windows
        const fileUrl = require("url").pathToFileURL(absolutePath).href;
        debugLog(`Trying dynamic import('${fileUrl}')...`);
        // Prefer direct dynamic import over eval if possible for clarity and security
        // const module = await import(fileUrl);
        // For now, keeping eval to match original structure
        module = await eval(`import('${fileUrl}')`);
        debugLog(`Successfully imported using dynamic import().`);
      } catch (importError: any) {
        debugLog(
          `Dynamic import() failed for ${ruleModulePath}: ${importError.message}`
        );
        // Re-throw the *import* error if dynamic import also fails
        // This will be caught by the handler in installSinglePackage
        throw importError;
      }
    } else {
      // Error from require was not ERR_REQUIRE_ESM
      debugLog(
        `Require failed for ${ruleModulePath} with unexpected error: ${error.message}`
      );
      // Re-throw the error if require failed for other reasons
      // This will be caught by the handler in installSinglePackage
      throw error;
    }
  }
  // Extract the default export if it exists, otherwise use the whole module
  const defaultExport = module?.default || module;
  debugLog(`Module imported. Type: ${typeof defaultExport}`);
  // Avoid logging potentially large module content by default
  // console.log(chalk.dim(`[Debug] Module content (keys): ${Object.keys(defaultExport || {}).join(', ')}`));
  return defaultExport;
}
</file>

<file path="package.json">
{
  "name": "vibe-rules",
  "version": "0.2.52",
  "description": "A utility for managing Cursor rules, Windsurf rules, and other AI prompts",
  "main": "dist/index.js",
  "bin": {
    "vibe-rules": "dist/cli.js"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "exports": {
    ".": "./dist/index.js",
    "./llms": "./dist/llms/index.js"
  },
  "scripts": {
    "build": "tsc",
    "start": "node dist/cli.js",
    "dev": "ts-node src/cli.ts",
    "publish": "bun run build && npm publish",
    "prepare": "vibe-rules install cursor"
  },
  "keywords": [
    "cursor",
    "windsurf",
    "rules",
    "ai",
    "prompts"
  ],
  "author": "Artem Murzin <hello@jart.lol>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/flowisgreat/vibe-rules.git"
  },
  "bugs": {
    "url": "https://github.com/flowisgreat/vibe-rules/issues"
  },
  "homepage": "https://github.com/flowisgreat/vibe-rules#readme",
  "dependencies": {
    "chalk": "^4.1.2",
    "commander": "^11.1.0",
    "fs-extra": "^11.3.0"
  },
  "devDependencies": {
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^20.10.4",
    "ts-node": "^10.9.1",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="ARCHITECTURE.md">
# vibe-rules Architecture

This document outlines the architecture of the vibe-rules utility - a tool for managing AI prompts for different editors.

**Note:** The tool is intended for global installation via `bun i -g vibe-rules`.

## Project Structure

```
vibe-rules/
├── src/                   # Source code
│   ├── cli.ts             # Command-line interface
│   ├── index.ts           # Main exports
│   ├── types.ts           # Type definitions
│   ├── schemas.ts         # Zod schema definitions (Added)
│   ├── llms/              # Rule definitions for package export (Added)
│   │   ├── index.ts       # Public rule export (intentionally empty)
│   │   └── internal.ts    # Internal rule definitions (not exported)
│   ├── providers/         # Provider implementations
│   │   ├── index.ts       # Provider factory
│   │   ├── cursor-provider.ts  # Cursor editor provider (Refactored)
│   │   ├── windsurf-provider.ts # Windsurf editor provider (Refactored)
│   │   ├── claude-code-provider.ts # Claude Code provider (Refactored)
│   │   ├── codex-provider.ts       # Codex provider (Refactored)
│   │   ├── clinerules-provider.ts  # Clinerules/Roo provider (Refactored)
│   │   └── zed-provider.ts         # Zed editor provider (Added)
│   └── utils/             # Utility functions
│       ├── path.ts        # Path helpers
│       ├── similarity.ts  # Text similarity utilities
│       └── rule-formatter.ts # Rule formatting utilities for metadata (Added)
│       └── single-file-helpers.ts # Helpers for single-file providers (Added)
│       └── rule-storage.ts # Helpers for internal rule storage (Added)
├── web/                   # Web interface
│   ├── pages/             # Vue/Nuxt pages
│   │   └── index.vue      # Landing page
│   ├── public/            # Public assets
│   └── nuxt.config.ts     # Nuxt configuration
├── package.json           # Project metadata and dependencies (Updated scripts)
└── README.md              # Project documentation (Updated examples)
└── ARCHITECTURE.md        # This file
```

## File Descriptions

### src/cli.ts

Defines the command-line interface using `commander`.

#### Helper Functions

- `installRule(ruleConfig: RuleConfig): Promise<void>` (Added)
  - Validates a `RuleConfig` object against `RuleConfigSchema`.
  - Saves the rule content to the common internal storage (`~/.vibe-rules/rules/<name>.txt`).
  - Handles errors during validation or saving.
- `clearExistingRules(pkgName: string, editorType: RuleType, options: { global?: boolean; target?: string }): Promise<void>` (Added)
  - Clears previously installed rule files associated with a specific NPM package before installing new ones.
  - Determines the target directory based on `editorType` and `options`.
  - **Behavior for Single-File Providers** (e.g., Windsurf, Claude Code, Codex):
    - Reads the determined single target file (e.g., `.windsurfrules`, `CLAUDE.md`).
    - Removes any XML-like blocks within the file where the tag name starts with the package prefix (e.g., finds and removes `<pkgName_rule1>...</pkgName_rule1>`, `<pkgName_anotherRule>...</pkgName_anotherRule>`).
    - Writes the modified content back to the file.
    - Does _not_ delete the file itself.
  - **Behavior for Multi-File Providers** (e.g., Cursor, Clinerules):
    - Deletes files within the target directory whose names start with `${pkgName}_`.

#### Commands

- `save <name> [options]`
  - Saves a rule to the local store (`~/.vibe-rules/rules/<name>.txt`).
  - Options: `-c, --content`, `-f, --file`, `-d, --description`.
  - Uses the `installRule` helper function.
- `list`
  - Lists all rules saved in the common local store (`~/.vibe-rules/rules`).
- `load <name> <editor> [options]` (Alias: `add`)
  - Applies a saved rule to a specific editor's configuration file.
  - Loads the rule content from the common store.
  - Determines the target file path based on editor type, options (`-g, --global`, `-t, --target`), and context.
  - Uses the appropriate `RuleProvider` to format and apply the rule (`appendFormattedRule`).
  - Suggests similar rule names if the requested rule is not found.
- `install <editor> [packageName] [options]` (Updated)
  - Installs rules exported from an NPM package directly into an editor configuration.
  - Arguments:
    - `<editor>`: Target editor type (mandatory).
    - `[packageName]`: Specific package to install from (optional, defaults to all deps).
  - Options:
    - `-g, --global`: Apply to global config path (similar to `load`).
    - `-t, --target <path>`: Custom target path (similar to `load`).
    - `--debug`: Enable verbose debug logging for the install process.
  - Behavior:
    - Determines the package(s) to process (specific one or all dependencies).
    - For each package, dynamically imports `<packageName>/llms`.
      - **Cleanup:** Calls `clearExistingRules` to remove rule files potentially installed previously from the same package (for multi-file providers like Cursor) or to remove corresponding XML blocks (for single-file providers).
      - **Module Loading:** Uses `require('module').createRequire` based on the CWD first for CommonJS compatibility. If that fails with `ERR_REQUIRE_ESM`, it falls back to using dynamic `import()` to support ES Modules.
    - Checks the default export:
      - If it's a **string**: Creates a single `RuleConfig` using the package name and content.
      - If it's an **array**: Validates against `VibePackageRulesSchema` (using `PackageRuleItemSchema` for flexibility) and uses the valid rule definitions (mapping `rule` to `content` if necessary).
    - For each valid `RuleConfig` obtained:
      - **Name Prefixing:** Ensures the `name` property of the `RuleConfig` starts with `${pkgName}-`. If the original name (from an object export or derived from the package name) doesn't have this prefix, it's added.
      - Gets the appropriate `RuleProvider` for the specified `<editor>`.
      - Determines the target file path based on editor type, rule name, and options (`-g`, `-t`).
      - Uses the provider's `appendFormattedRule` to apply the rule to the target path.
    - Does **not** save rules to the common local store (`~/.vibe-rules/rules`).
    - **Error Handling (Updated):**
      - When attempting to import `<packageName>/llms`:
        - **Module Not Found/Not Exported:** Errors like `MODULE_NOT_FOUND`, `ERR_MODULE_NOT_FOUND`, or `ERR_PACKAGE_PATH_NOT_EXPORTED` are logged with a descriptive message if `--debug` is enabled. Otherwise, the package is typically skipped silently to avoid excessive output when checking many dependencies.
        - **Syntax Errors:** If a `SyntaxError` occurs in the imported module, an error message is printed to the console, clearly indicating that the issue lies within the syntax of the rule module of the specified package.
        - **Initialization Errors (Client-Side Errors):** If the module is found and parsed but throws an error during its own initialization phase (e.g., internal file access errors like `ENOENT`, or other runtime errors within the module's top-level code), a detailed error message is printed. This message explicitly suggests that the problem likely originates from within the imported package itself, providing the original error message from the package for easier debugging by the package maintainers or users.
      - Other errors during the rule application process for a specific rule are logged, but the `install` command will attempt to continue with other rules or packages.

### src/types.ts

Defines the core types and interfaces used throughout the application.

#### `RuleConfig`

- Interface for storing rule information
- Properties:
  - `name`: string - The name of the rule
  - `content`: string - The content of the rule
  - `description?`: string - Optional description

#### `RuleType`

- Enum defining supported editor types
- Values:
  - `CURSOR`: "cursor" - For Cursor editor
  - `WINDSURF`: "windsurf" - For Windsurf editor
  - `CLAUDE_CODE`: "claude-code" - For Claude Code IDE (Added)
  - `CODEX`: "codex" - For Codex IDE (Added)
  - `CLINERULES`: "clinerules" - For Cline/Roo IDEs (Added)
  - `ROO`: "roo" - Alias for CLINERULES (Added)
  - `ZED`: "zed" - For Zed editor (Added)
  - `CUSTOM`: "custom" - For custom implementations

#### `RuleProvider`

- Interface that providers must implement
- Methods:
  - `saveRule(config: RuleConfig, options?: RuleGeneratorOptions): Promise<string>` - Saves a rule definition (often internally) and returns the path
  - `loadRule(name: string): Promise<RuleConfig | null>` - Loads a rule definition by name
  - `listRules(): Promise<string[]>` - Lists all available rule definitions
  - `appendRule(name: string, targetPath?: string, isGlobal?: boolean): Promise<boolean>` - Loads a rule definition and applies it to a target file/directory, considering global/local context
  - `appendFormattedRule(config: RuleConfig, targetPath: string, isGlobal?: boolean): Promise<boolean>` - Formats and applies a rule definition directly
  - `generateRuleContent(config: RuleConfig, options?: RuleGeneratorOptions): string` - Generates formatted rule content suitable for the specific provider/IDE

#### `RuleGeneratorOptions`

- Interface for optional configuration when generating or applying rules
- Properties:
  - `description?`: string - Custom description (used by some providers like Cursor)
  - `isGlobal?`: boolean - Hint for providers supporting global/local paths (e.g., Claude, Codex)
  - `alwaysApply?`: boolean - Cursor-specific metadata.
  - `globs?`: string | string[] - Cursor-specific metadata.

### src/schemas.ts (Added)

Defines Zod schemas for validating rule configurations.

#### `RuleConfigSchema`

- Zod schema corresponding to the `RuleConfig` interface.
- Validates `name` (non-empty string), `content` (non-empty string), and optional `description` (string).
- Used by the `save` command and potentially internally.

#### `PackageRuleObjectSchema` (Added)

- Zod schema for the flexible rule object structure found in `package/llms` exports.
- Validates:
  - `name`: string (non-empty)
  - `rule`: string (non-empty) - Note: uses `rule` field for content.
  - `description?`: string
  - `alwaysApply?`: boolean - Cursor-specific metadata.
  - `globs?`: string | string[] - Cursor-specific metadata.

#### `PackageRuleItemSchema` (Added)

- Zod schema representing a single item in the `package/llms` array export.
- It's a union of:
  - `z.string().min(1)`: A simple rule string.
  - `PackageRuleObjectSchema`: The flexible rule object.

#### `VibePackageRulesSchema` (Added)

- Zod schema for the entire default export of `package/llms` when it's an array.
- Defined as `z.array(PackageRuleItemSchema)`.
- Used by the `install` command to validate package exports.

#### `VibeRulesSchema`

- Original Zod schema for an array of basic `RuleConfigSchema`. Kept for potential other uses but **not** the primary schema for the `install` command anymore.

### src/utils/path.ts

Provides utility functions for managing file paths related to rules and IDE configurations.
Utilizes `debugLog` from `cli.ts` for conditional logging in `ensureDirectoryExists` (Updated).

#### `RULES_BASE_DIR`

- Constant storing the base directory for vibe-rules internal storage (`~/.vibe-rules`)

#### `CLAUDE_HOME_DIR`, `CODEX_HOME_DIR`

- Constants storing the conventional home directories for Claude (`~/.claude`) and Codex (`~/.codex`)

#### `getCommonRulesDir(): string`

- Gets (and ensures exists) the directory for storing common rule definitions within `RULES_BASE_DIR`
- Returns: The path to `~/.vibe-rules/rules`

#### `getInternalRuleStoragePath(ruleType: RuleType, ruleName: string): string`

- Gets the path for storing internal rule _definitions_ based on type.
- Parameters:
  - `ruleType`: The type of rule
  - `ruleName`: The name of the rule
- Returns: Path within `~/.vibe-rules/<ruleType>/<ruleName>.txt`

#### `getRulePath(ruleType: RuleType, ruleName: string, isGlobal: boolean = false, projectRoot: string = process.cwd()): string`

- Gets the _actual_ expected file or directory path where a rule should exist for the target IDE/tool.
- Parameters:
  - `ruleType`: The type of rule
  - `ruleName`: The name of the rule (used by some types like Cursor)
  - `isGlobal`: Flag indicating global context (uses home dir paths for Claude/Codex)
  - `projectRoot`: The root directory for local project paths
- Returns: The specific path (e.g., `~/.claude/CLAUDE.md`, `./.cursor/rules/my-rule.mdc`, `./.clinerules`, `./.rules` for Zed)

#### `getDefaultTargetPath(ruleType: RuleType, isGlobalHint: boolean = false): string`

- Gets the default target directory or file path where rules of a certain type are typically applied (used by commands like `apply` if no target is specified).
- Parameters:
  - `ruleType`: The type of rule/editor
  - `isGlobalHint`: Hint for global context
- Returns: The conventional default path (e.g., `~/.codex`, `./.cursor/rules`, `./.clinerules`, `./.rules` for Zed)

#### `slugifyRuleName(name: string): string`

- Converts a rule name to a filename-safe slug.
- Parameters:
  - `name`: The rule name to convert
- Returns: A slug-formatted string

### src/utils/similarity.ts

Provides text similarity utilities for finding related rules based on name similarity.

#### `levenshteinDistance(a: string, b: string): number`

- Calculates the Levenshtein distance between two strings
- Parameters:
  - `a`: First string
  - `b`: Second string
- Returns: A distance score (lower means more similar)

#### `calculateSimilarity(a: string, b: string): number`

- Calculates similarity score between two strings
- Parameters:
  - `a`: First string
  - `b`: Second string
- Returns: A similarity score between 0 and 1 (higher means more similar)

#### `findSimilarRules(notFoundName: string, availableRules: string[], limit: number = 5): string[]`

- Finds similar rule names to a given query
- Parameters:
  - `notFoundName`: The rule name that wasn't found
  - `availableRules`: List of available rule names
  - `limit`: Maximum number of similar rules to return (default: 5)
- Returns: Array of similar rule names sorted by similarity (most similar first)

### src/utils/rule-formatter.ts (Added)

Provides utility functions for formatting rule content with metadata like `alwaysApply` and `globs`.

#### `formatRuleWithMetadata(config: RuleConfig, options?: RuleGeneratorOptions): string`

- Formats rule content with human-readable metadata lines at the beginning
- Parameters:
  - `config`: The rule config to format
  - `options`: Optional metadata like alwaysApply and globs
- Returns: The formatted rule content with metadata lines included
- Handles both alwaysApply (true/false) and globs (string or array)
- Used by non-cursor providers to include metadata in their rule content

#### `createTaggedRuleBlock(config: RuleConfig, options?: RuleGeneratorOptions): string`

- Creates a complete XML-like block for a rule, with start/end tags and formatted content
- Parameters:
  - `config`: The rule config to format
  - `options`: Optional metadata like alwaysApply and globs
- Returns: The complete tagged rule block with metadata
- Used by providers that store rules in a single file with XML-like tags (via `single-file-helpers.ts`)

### src/utils/single-file-helpers.ts (Added)

Provides utility functions specific to providers that manage rules within a single configuration file using tagged blocks.
Utilizes `debugLog` from `cli.ts` for conditional logging (Updated).

#### `appendOrUpdateTaggedBlock(targetPath: string, config: RuleConfig, options?: RuleGeneratorOptions, appendInsideVibeToolsBlock: boolean = false): Promise<boolean>` (Updated)

- Encapsulates the logic for managing rules in single-file providers (Windsurf, Claude Code, Codex, Zed).
- Reads the `targetPath` file content.
- Uses `createTaggedRuleBlock` to generate the XML-like block for the rule.
- **Bug Fix:** Now properly handles file creation for dot-files (e.g., `.rules`, `.windsurfrules`):
  - Explicitly checks if a target file exists using `fs.stat`
  - If the path exists but is a directory, removes it with `fs.rm` (recursive: true)
  - For new files, uses `fsExtra.ensureFileSync` to create an empty file before writing content
  - This prevents the dot-files from being incorrectly created as directories
- Searches for an existing block using a regex based on the `config.name` (e.g., `<rule-name>...</rule-name>`).
- **If found:** Replaces the existing block with the newly generated one.
- **If not found:** Appends the new block.
  - If `appendInsideVibeToolsBlock` is `true` (for Claude, Codex), it attempts to insert the block just before the `</vibe-tools Integration>` tag if present.
  - Otherwise (or if the integration block isn't found), it appends the block to the end of the file.
- Writes the updated content back to the `targetPath`.
- Ensures the parent directory exists using `ensureDirectoryExists`.
- Handles file not found errors gracefully (creates the file).
- Returns `true` on success, `false` on failure.

### src/utils/rule-storage.ts (Added)

Provides utility functions for interacting with the internal rule definition storage located at `~/.vibe-rules/rules/<ruleType>/*`.

#### `saveInternalRule(ruleType: RuleType, config: RuleConfig): Promise<string>`

- Saves a rule definition (`config.content`) to the internal storage path determined by `ruleType` and `config.name`.
- Ensures the target directory exists.
- Returns the full path where the rule was saved.

#### `loadInternalRule(ruleType: RuleType, name: string): Promise<RuleConfig | null>`

- Loads a rule definition from the internal storage file corresponding to `ruleType` and `name`.
- Returns a `RuleConfig` object containing the name and content if found, otherwise returns `null`.

#### `listInternalRules(ruleType: RuleType): Promise<string[]>`

- Lists the names of all rules (.txt files) stored internally for the given `ruleType`.
- Returns an array of rule names (filenames without the .txt extension).

### src/providers/index.ts

Contains a factory function `getRuleProvider(ruleType: RuleType)` that returns the appropriate provider instance based on the `RuleType` enum.
Handles `CURSOR`, `WINDSURF`, `CLAUDE_CODE`, `CODEX`, `CLINERULES`, `ROO`, and `ZED` (Added).

### src/providers/cursor-provider.ts (Refactored)

Implementation of the `RuleProvider` interface for Cursor editor.

#### `CursorRuleProvider` (class)

##### Methods: `generateRuleContent`, `saveRule`, `loadRule`, `listRules`, `appendRule`, `appendFormattedRule`

- Handles Cursor's `.mdc` files with frontmatter.
- **`saveRule`, `loadRule`, `listRules` (Refactored):** Now use utility functions from `src/utils/rule-storage.ts` to interact with internal storage.
- **`generateRuleContent` (Updated):**
  - Now accepts `RuleGeneratorOptions` (which includes optional `alwaysApply` and `globs`).
  - If `alwaysApply` or `globs` are present in the options, they are included in the generated frontmatter.
  - Uses `options.description` preferentially over `config.description` if provided.
  - Uses a custom internal function to format the frontmatter instead of the `yaml` library.
- `appendRule` loads a rule from internal storage and calls `appendFormattedRule`. Note that rules loaded this way might not have the dynamic `alwaysApply`/`globs` metadata unless it was also saved (currently it isn't).
- **`appendFormattedRule` (Updated):**
  - Now accepts `RuleGeneratorOptions`.
  - Passes these options along to `generateRuleContent` to allow for dynamic frontmatter generation based on the source of the rule (e.g., from `install`
</file>

</files>
